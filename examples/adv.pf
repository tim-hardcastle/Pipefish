import

"strings"
"path/filepath"
NULL::"terminal"

newtype

Location = struct(description, north, south, east, west string)
Object = struct(description, location string)
GameState = struct(locations, objects map, playerLocation, output string)

var

state = GameState(map(), map(), "", "")

cmd // The imperative shell.

init :
    global state
    get info from File (filepath.join $_moduleDirectory, "locations.rsc")
    linesToProcess = strings.split(info, "\n")
    lines = linesToProcess
    state = state with locations::slurpLocations(linesToProcess)
    state = state with playerLocation::linesToProcess[0]
    get info from File (filepath.join $_moduleDirectory, "objects.rsc")
    state = state with objects::slurpObjects(strings.split info, "\n")

main :
    global state
    post "\n" + describe(state[playerLocation], state) + "\n"
    for :
        get userInput from Keyboard "What now? "
        strings.toLower(userInput) == "quit" :
            break
        else :
            state = doTheThing(userInput, state)
            post "\n" + state[output] + "\n"
   
// And the functional core.
const

VERBS = set("go", "take", "drop", "examine", "inventory", "look")
INTRANSITIVE_VERBS = set("inventory", "look")
SYNONYMS = map("get"::"take", "inv"::"inventory", "ex"::"examine", "n"::"north", 
            .. "s"::"south", "e"::"east", "w"::"west", " the "::" ")
DIRECTIONS = map("north"::north, "south"::south, "east"::east, "west"::west)
VOWELS = set("a", "e", "i", "o", "u")

def

// This selects which function to call based on the parsed user input.
doTheThing(input string, S GameState) :
    not (len(parsedInput) in set(1, 2)) :
        S with output::"I don't understand that."
    not verb in VERBS :
        S with output::"I don't know the word " + verb + "."
    not verb in INTRANSITIVE_VERBS and len(parsedInput) == 1 :
        S with output::"The verb " + verb + " requires a noun."
    verb in INTRANSITIVE_VERBS and len(parsedInput) == 2 :
        S with output::"The verb " + verb + " requires no noun."
    specialEffects(verb, noun, S) 
    verb == "go" :
        doMove(noun, S)
    verb == "look" :
        doLook(S)
    verb == "take" :
        doTake(noun, S)
    verb == "drop" :
        doDrop(noun, S)
    verb == "examine" :
        doExamine(noun, S)
    verb == "inventory" :
        doInventory(S)
    else :
        S with output::"I don't know how to do that!"
given :
    parsedInput = parseUserInput(input)
    verb = parsedInput[0]
    noun = parsedInput[1]

// Functions for parsing input.

parseUserInput(input string) :
    input -> strings.toLower -> strings.split(that, " ") ..
       .. >> substituteSynonyms -> addImplicitGo

substituteSynonyms(s string) :
    s in keys SYNONYMS :
        SYNONYMS[s]
    else :
        s

addImplicitGo(L list) :
    len(L) == 1 and L[0] in keys DIRECTIONS:
        ["go"] + L
    else :
        L

// Functions for describing a location and its contents.

describe(loc string, S GameState) : loc + "\n\n" + S[locations][loc][description] //..
                                // .. + describeObjects(loc, S)


describeObjects(loc, S) :
    objectsPresent == [] :
        ""
    else :
        "\n\nThere is" + string(objectsPresent) + " here."
given :
    objectsPresent = ((keys S[objects]) ?> S[objects][that][location] == loc)

describeList(L list) :
    from a = "" for i::item = range L :
        a + objectWithArticle(item) + separator(i, len(L)-1)     

objectWithArticle(s string) :
    s[0] in VOWELS :
        " an " + s
    else :
        " a " + s

separator(pos, end) :
    pos == end :
        ""
    pos == 1 and end == 2 :
        " and"
    pos == end - 1 :
        ", and"
    else :
        ","

// Functions for executing the end-user's instructions.

doMove(dir string, S GameState) : 
    not dir in keys DIRECTIONS :
        S with output::"That's not a direction!"
    newLocation == "" : 
        S with output::"You can't go that way!"
    else :
        S with playerLocation::newLocation, output::describe(newLocation, S)
given :
    directionFromString = DIRECTIONS[dir] 
    newLocation = S[locations][S[playerLocation]][directionFromString]

doTake(obj string, S GameState) : 
    not obj in keys S[objects] : 
        S with output::"I don't know what that is."
    not S[objects][obj][location] == S[playerLocation] :
        S with output::"I don't see that here."
    else :
        S with [objects, obj, location]::"Player", output::"You take the " + obj + "."

doDrop(obj string, S GameState) : 
    not obj in keys S[objects] : 
        S with output::"I don't know what that is."
    not S[objects][obj][location] == "Player" :
        S with output::"You don't have that."
    else :
        S with [objects, obj, location]::S[playerLocation], output::"You drop the " + obj + "."

doExamine(obj string, S GameState) : 
    not obj in keys S[objects] : 
        S with output::"I don't know what that is."
    not S[objects][obj][location] in set(S[playerLocation], "Player") :
        S with output::"I don't see that here."
    else :
        S with output::S[objects][obj][description]

doInventory(S GameState) :
    objectsPlayerIsCarrying == [] :
        S with output::"You aren't carrying anything."
    else :
        S with output::"You have" + describeList(objectsPlayerIsCarrying) + "."
given :
    objectsPlayerIsCarrying = ((keys S[objects]) ?> S[objects][that][location] == "Player")

doLook(S GameState) :
    S with output::describe(S[playerLocation], S)

// We perform any special effects.
specialEffects(verb, noun string, S GameState) :
    verb == "take" and noun == "cat" :
        S with output::"The cat eludes your grip."
    verb == "drop" and noun == "ring" and S[playerLocation] == "The brink of an active volcano" :
        S with [objects, "ring", location]::"Limbo",
            .. output::"You cast the magical ring into the volcano. Oh, that's original."

// These turn the raw text files we started with into appropriate
// data structures.

slurpLocations(L list) : 
    from M = map() for i = 0; i < len(L); i + 6 :
        M with L[i]::Location(L[i + 1], L[i + 2], L[i + 3], L[i + 4], L[i + 5])

slurpObjects(L list) : 
    from M = map() for i = 0; i < len(L); i + 3 :
        M with L[i]::Object(L[i + 1], L[i + 2])
