package service

import (
	"os"
	"pipefish/source/ast"
	"pipefish/source/dtypes"
	"pipefish/source/err"
	"pipefish/source/parser"
	"pipefish/source/settings"
	"pipefish/source/text"
	"pipefish/source/token"
	"pipefish/source/values"

	"fmt"
	"reflect"
	"strconv"
	"strings"
	"testing"
)

type Compiler struct {
	// Permanent state, i.e. it is unchanged after initialization.
	Vm                                  *Vm                                // The vm we're compiling to.
	P                                   *parser.Parser                     // The parser the compiler's using to parse with..
	EnumElements                        map[string]uint32                  // Map from the names of the enum elements the compiler knows about to memory locations where they're stored. TODO --- not that.
	GlobalConsts                        *Environment                       // The global constants of the module.
	GlobalVars                          *Environment                       // The global variables of the module.
	Fns                                 []*CpFunc                          // The functions the compiler knows about, in a format it can use.
	typeNameToTypeScheme                map[string]AlternateType           // A map from the names of built-in or declared concrete or abstract types to an AlternateType typescheme representing them.
	Services                            map[string]*Service                // Both true internal services, and stubs that call the externals.
	CallHandlerNumbersByName            map[string]uint32                  // Map from the names of external services to their index as stored in the vm.
	Timestamp                           int64                              // The timestamp from the source file. TODO --- "the" source file? Wat about NULL-imports?
	ScriptFilepath                      string                             // Where the script for the module is (where "the" script is the one that supplies the namespace, not the NULL-imports).
	structDeclarationNumberToTypeNumber map[int]values.ValueType           // Maps the order of the declaration of the struct in the script to its type number in the VM. TODO --- there must be something better than this.
	typeToCloneGroup                    map[values.ValueType]AlternateType // A map from any clonable or clone type to an alt type containing the parent type and its clones.
	labelResolvingCompilers             []*Compiler                        // We use this to resolve the meaning of labels and enums.
	TupleType                           uint32                             // Location of a constant saying {TYPE, <type number of tuples>}, so that 'type (x tuple)' in the builtins has something to return. Query, why not just define 'type (x tuple) : tuple' ?
	
	// Temporary state.
	ThunkList       []ThunkData   // Records what thunks we made so we know what to unthunk at the top of the function.
	recursionStore  []bkRecursion // Places in the code where we need to go back and doctor it to make the recursion work for outer functions.
	lambdaMemStarts []uint32      // A stack for the start (in memory, not code) of the lambda we're compiling so that if it turns out to be recursive we know the low bound of where to start saving memory from.
	forData         [][]any       // A stack (one list for each nested 'for' loop) of lists of gotos etc generated by 'break' and 'continue'.
	showCompile     bool          // Whether we show the internals of the compiler at compile time.
}

// Initializes a compiler.
func NewCompiler(p *parser.Parser) *Compiler {
	newC := &Compiler{
		P:                        p,
		EnumElements:             make(map[string]uint32),
		GlobalConsts:             NewEnvironment(),
		GlobalVars:               NewEnvironment(),
		ThunkList:                []ThunkData{},
		Fns:                      []*CpFunc{},
		Services:                 make(map[string]*Service),
		CallHandlerNumbersByName: make(map[string]uint32),
		typeToCloneGroup:         make(map[values.ValueType]AlternateType),
		typeNameToTypeScheme:     INITIAL_TYPE_SCHEMES,
	}
	newC.pushRCompiler(newC)
	return newC
}

// The `context` is passed around the compiler to keep track of what it's trying to do. Is it compiling a function
// body? Is it meant to be logging anything? Is it compiling a function, a command, an expression from the REPL? Etc.
type context struct {
	env       *Environment    // The association of variable names to variable locations.
	fName     string          // If we're compiling a function, the name of the function we're compiling.
	access    cpAccess        // Whether we are compiling the body of a command; of a function; something typed into the REPL, etc.
	isReturn  bool            // Is the value of the node to be evaluated potentially a return value of the function being compiled?
	typecheck finiteTupleType // The type(s) for the compiler to check for if isReturn is true; nil if no return types are defined.
	lowMem    uint32          // Where the memory of the function we're compiling (if indeed we are) starts, and so the lowest point from which we may need to copy memory in case of recursion.
	logFlavor LogFlavor       // Whether we should be logging something and if so what.
}

// Unless we're going down a branch, we want the new context for each node compilation to have no forward type-checking.
// This function concisely removes it.
func (ctxt context) x() context {
	ctxt.isReturn = false
	return ctxt
}

// This is the type of the access that the compiler has at any given point in the compilation. Are we compiling code in a function,
// a command, an expression from the REPL?
type cpAccess int

const ( // We use this to keep track of what we're doing so we don't e.g. call a command from a function, or let a command see the globals without a `global` keyword, etc.
	REPL   cpAccess = iota // Call from the REPL, or an external service. TODO --- distinguish them for clarity?
	CMD                    // We're in a command.
	DEF                    // We're in a function.
	INIT                   // We're initializing the global variables.
	LAMBDA                 // We're in a lambda function.
)

// The `Do` function of the VM is what a Service calls to get it to evaluate a line of code from the REPL.
// It parses the line to an AST, initializes the context, calls `CompileNode` with the AST and the context
// as arguments, runs the resulting code, rolls back the VM, and returns the value it got.
func (cp *Compiler) Do(line string) values.Value {
	state := cp.getState()
	cT := cp.CodeTop()
	node := cp.P.ParseLine("REPL input", line)
	if settings.SHOW_PARSER {
		fmt.Println("Parsed line:", node.String())
	}
	if cp.P.ErrorsExist() {
		return val(values.ERROR, &err.Error{})
	}
	ctxt := context{env: cp.GlobalVars, access: REPL, lowMem: DUMMY, logFlavor: LF_NONE}
	cp.CompileNode(node, ctxt)
	if cp.P.ErrorsExist() {
		return val(values.ERROR, &err.Error{})
	}
	cp.Emit(Ret)
	cp.cm("Calling Run from Do.", node.GetToken())
	cp.Vm.Run(cT)
	result := cp.Vm.Mem[cp.That()]
	cp.rollback(state, node.GetToken())
	return result
}

// The heart of the compiler. It starts by taking a snapshot of the vm. It then does a big switch on the node type
// and compiles accordingly. It then performs some sanity checks and, if the compiled expression is constant,
// evaluates it and uses the snapshot to roll back the vm.
//
// The node types in the switch are in alphabetical order.
func (cp *Compiler) CompileNode(node ast.Node, ctxt context) (AlternateType, bool) {
	cp.cm("Compiling node of type "+(reflect.TypeOf(node).String())[5:]+" with literal "+text.Emph(node.GetToken().Literal)+".", node.GetToken())
	cp.cm("Node is "+node.String(), node.GetToken())
	cp.showCompile = settings.SHOW_COMPILER && !(settings.IGNORE_BOILERPLATE && settings.ThingsToIgnore.Contains(node.GetToken().Source)) || testing.Testing()
	rtnTypes, rtnConst := AlternateType{}, true
	state := cp.getState()
	cT := cp.CodeTop()
	env := ctxt.env
	ac := ctxt.access
NodeTypeSwitch:
	switch node := node.(type) {
	// Note that assignments in `given` blocks and var and const initialization are taken care of by the vmmaker, so we only have to deal with the cases where
	// the assignment is in the body of a function or in the REPL.
	case *ast.AssignmentExpression:
		cp.cm("Assignment from REPL or in 'cmd' section", node.GetToken())
		sig, err := cp.P.RecursivelySlurpSignature(node.Left, "*inferred*")
		if err != nil {
			cp.P.Throw("comp/assign/lhs/b", node.Left.GetToken())
			break NodeTypeSwitch
		}
		cp.cm("Assignment signature is "+text.Emph(sig.String()), &node.Token)
		rhsIsError := bkEarlyReturn(DUMMY) // TODO --- since assigning an error would violate a type check, which we also perform, is this necessary?
		rTypes, _ := cp.CompileNode(node.Right, ctxt.x())
		rhsResult := cp.That()
		if rTypes.Contains(values.ERROR) {
			rhsIsError = cp.vmConditionalEarlyReturn(Qtyp, rhsResult, uint32(values.ERROR), rhsResult)
			rtnTypes = AltType(values.SUCCESSFUL_VALUE, values.ERROR)
		} else {
			rtnTypes = AltType(values.SUCCESSFUL_VALUE)
		}
		rtnConst = false // The initialization/mutation in the assignment makes it variable whatever the RHS is.
		types := rTypes.without(simpleType(values.ERROR))
		newSig := cpSig{} // A more flexible form of signature that allows the types to be represented as a string or as an AlternateType.
		// We need to do typechecking differently according to whether anything on the LHS is a global, in which case we need to early-return an error from the typechecking.
		flavor := CHECK_LOCAL_CMD_ASSIGNMENTS
		for i, pair := range sig {
			v, ok := env.getVar(pair.VarName)
			if ok {
				cp.cm("Inferring the type of a variable "+text.Emph(pair.VarName)+" already defined ", &node.Token)
				if sig.GetVarType(i) != "*inferred*" { // Then as we can't change the type of an existing variable, we must check that we're defining it the same way.
					if !Equals(v.types, cp.getAlternateTypeFromTypeName(sig[i].VarType)) {
						cp.P.Throw("comp/assign/redefine/b", node.GetToken())
						break NodeTypeSwitch
					}
				}
				if v.access != REFERENCE_VARIABLE { // TODO --- THere's probably a more elgant way of dealing with the reference variable thing if I think about it, but as I intend to type them anyway and this will get refactored away it's not a big deal.
					newSig = append(newSig, NameAlternateTypePair{pair.VarName, v.types})
				} else {
					newSig = append(newSig, NameAlternateTypePair{pair.VarName, cp.getAlternateTypeFromTypeName("any?")})
				}
				if v.access == GLOBAL_CONSTANT_PRIVATE || v.access == LOCAL_VARIABLE_THUNK || v.access == LOCAL_CONSTANT || v.access == LOCAL_FUNCTION_CONSTANT ||
					v.access == VERY_LOCAL_CONSTANT || v.access == VERY_LOCAL_VARIABLE || v.access == FUNCTION_ARGUMENT || v.access == LOCAL_FUNCTION_THUNK {
					cp.P.Throw("comp/assign/immutable", node.Left.GetToken())
					break NodeTypeSwitch
				}
				if ac == REPL && (ALL_PRIVATE_ACCESS.Contains(v.access)) {
					cp.P.Throw("comp/assign/private", node.Left.GetToken())
					break NodeTypeSwitch
				}
				if ac == REPL && (ALL_CONSTANT_ACCESS.Contains(v.access)) {
					cp.P.Throw("comp/assign/const", node.Left.GetToken())
					break NodeTypeSwitch
				}
				if v.access == GLOBAL_VARIABLE_PUBLIC {
					flavor = CHECK_GLOBAL_ASSIGNMENTS
				}
			} else { // The variable doesn't already exist.
				cp.cm("Assignment creating local variable "+text.Emph(sig.String())+".", &node.Token)
				if ac == REPL {
					cp.P.Throw("comp/assign/error", node.Left.GetToken())
					break NodeTypeSwitch
				}
				cp.Reserve(values.UNDEFINED_VALUE, DUMMY, node.GetToken())
				if pair.VarType == "tuple" {
					cp.cm("Adding variable in ASSIGN, 1", node.GetToken())
					cp.AddVariable(env, pair.VarName, LOCAL_VARIABLE, cp.Vm.AnyTuple, node.GetToken())
					newSig = append(newSig, ast.NameTypenamePair{pair.VarName, "tuple"})
				} else {
					typesAtIndex := typesAtIndex(types, i)
					cp.cm("Adding variable in ASSIGN, 2", node.GetToken())
					cp.AddVariable(env, pair.VarName, LOCAL_VARIABLE, typesAtIndex, node.GetToken())
					if sig[i].VarType == "*inferred*" {
						newSig = append(newSig, NameAlternateTypePair{pair.VarName, typesAtIndex})
					} else {
						newSig = append(newSig, ast.NameTypenamePair{pair.VarName, sig[i].VarType})
					}
				}
			}
		}
		cp.cm("Typechecking and inserting result into variables.", node.GetToken())
		typeCheckFailed := cp.emitTypeChecks(rhsResult, types, env, newSig, ac, node.GetToken(), flavor)
		cp.put(Asgm, values.C_OK)
		cp.vmComeFrom(rhsIsError, typeCheckFailed)
		break NodeTypeSwitch
	case *ast.Bling:
		cp.P.Throw("comp/bling/wut", node.GetToken())
		break
	case *ast.BooleanLiteral:
		cp.Reserve(values.BOOL, node.Value, node.GetToken())
		rtnTypes, rtnConst = AltType(values.BOOL), true
		break
	case *ast.ComparisonExpression:
		if node.Operator == "==" {
			rtnTypes, rtnConst = cp.compileEquals(node, ctxt.x())
			break
		}
		if node.Operator == "!=" {
			rtnTypes, rtnConst = cp.compileEquals(node, ctxt.x())
			cp.put(Notb, cp.That())
			break
		}
	case *ast.FloatLiteral:
		cp.Reserve(values.FLOAT, node.Value, node.GetToken())
		rtnTypes, rtnConst = AltType(values.FLOAT), true
		break
	case *ast.ForExpression:
		rtnTypes = cp.compileForExpression(node, ctxt)
		rtnConst = false // If anyone misses out on an optimization because they manage to write a constant for loop this should if anything be a warning rather than an oportunity for optimization.
		break
	case *ast.FuncExpression:
		cp.compileLambda(env, ctxt, node, node.GetToken())
		rtnTypes = AltType(values.FUNC) // In the case where the function is a constant (i.e. has no captures), the compileLambda function will emit an assignment rather than a lambda factory.)
		rtnConst = false
		break // Things that return functions and snippets are not folded, even if they are constant.
	case *ast.Identifier:
		switch node.Value {
		case "continue":
			cp.emitContinue(&node.Token)
			rtnTypes, rtnConst = AltType(), false
			break NodeTypeSwitch
		case "break":
			cp.emitBreakWithoutValue(&node.Token)
			rtnTypes, rtnConst = AltType(), false
			break NodeTypeSwitch
		case "NULL":
			cp.Reserve(values.NULL, nil, &node.Token)
			rtnTypes, rtnConst = altType(values.NULL), false // Yes it is a const but there's nothing to roll back so ...
			break NodeTypeSwitch
		case "OK":
			cp.Reserve(values.SUCCESSFUL_VALUE, nil, &node.Token)
			rtnTypes, rtnConst = altType(values.SUCCESSFUL_VALUE), false
			break NodeTypeSwitch
		}
		var enumCompiler *Compiler
		if node.Namespace == nil {
			enumCompiler = cp.topRCompiler()
		} else {
			enumCompiler = cp.getResolvingCompiler(node, node.Namespace, ac)
		}
		enumElement, ok := enumCompiler.EnumElements[node.Value]
		if ok {
			if cp.Vm.concreteTypeInfo[cp.Vm.Mem[enumElement].T].isPrivate() {
				cp.P.Throw("comp/private/enum", node.GetToken(), cp.Vm.DescribeType(cp.Vm.Mem[enumElement].T, LITERAL))
				break
			}
			cp.put(Asgm, enumElement)
			rtnTypes, rtnConst = AltType(cp.Vm.Mem[enumElement].T), true
			break
		}
		labelNumberLocation, ok := cp.Vm.FieldLabelsInMem[node.Value]
		if ok {
			if ac == REPL && cp.Vm.LabelIsPrivate[cp.Vm.Mem[labelNumberLocation].V.(int)] {
				cp.P.Throw("comp/private/label", node.GetToken())
				break
			}
			cp.put(Asgm, labelNumberLocation)
			rtnTypes, rtnConst = AltType(values.LABEL), true
			break
		}
		var v *variable
		resolvingCompiler := cp.getResolvingCompiler(node, node.Namespace, ac)
		if resolvingCompiler != cp {
			v, ok = resolvingCompiler.GlobalConsts.getVar(node.Value)
		} else {
			v, ok = env.getVar(node.Value)
		}
		if !ok {
			cp.P.Throw("comp/ident/known", node.GetToken())
			break
		}
		if (v.access == GLOBAL_CONSTANT_PRIVATE || v.access == GLOBAL_VARIABLE_PRIVATE) && ac == REPL {
			cp.P.Throw("comp/ident/private", node.GetToken())
			break
		}
		if v.access == LOCAL_VARIABLE_THUNK || v.access == LOCAL_FUNCTION_THUNK {
			cp.Emit(Untk, v.mLoc)
		}
		if v.access == REFERENCE_VARIABLE {
			cp.put(Dref, v.mLoc)
			rtnTypes = cp.getAlternateTypeFromTypeName("any?")
		} else {
			cp.put(Asgm, v.mLoc)
			rtnTypes = v.types
		}
		rtnConst = ALL_CONSTANT_ACCESS.Contains(v.access)
		break
	case *ast.IndexExpression:
		containerType, ctrConst := cp.CompileNode(node.Left, ctxt.x())
		container := cp.That()
		var whatAccess varAccess
		if ctrConst {
			whatAccess = VERY_LOCAL_CONSTANT
		} else {
			whatAccess = VERY_LOCAL_VARIABLE
		}
		envWithThat := &Environment{data: map[string]variable{"that": {mLoc: cp.That(), access: whatAccess, types: containerType}}, Ext: env}
		newContext := ctxt.x()
		newContext.env = envWithThat
		indexType, idxConst := cp.CompileNode(node.Index, newContext)
		index := cp.That()
		rtnConst = ctrConst && idxConst
		errTok := cp.reserveToken(node.GetToken())
		// Things we can index:
		// Lists, by integers; or a pair for a slice.
		// Tuples, ditto.
		// Strings, ditto.
		// Pairs, by integers.
		// Names of enum types, by integers. Query, add slice too?
		// Maps, by any value we can Compare with another value.
		// Structs, by a label, preferably an appropriate one.

		if len(containerType.intersect(cp.Vm.sharedTypenameToTypeList["listlike"])) == len(containerType) {
			if indexType.isOnlyCloneOf(cp.Vm, values.INT) {
				cp.put(IdxL, container, index, errTok)
				rtnTypes = cp.getAlternateTypeFromTypeName("any?").Union(AltType(values.ERROR))
				break
			}
			if indexType.isOnlyCloneOf(cp.Vm, values.PAIR) {
				cp.put(SliL, container, index, errTok)
				rtnTypes = containerType
			}
			if indexType.cannotBeACloneOf(cp.Vm, values.INT, values.PAIR) {
				cp.P.Throw("comp/index/list", node.GetToken())
				break
			}
			rtnTypes = cp.getAlternateTypeFromTypeName("any?").Union(AltType(values.ERROR))
		}
		if len(containerType.intersect(cp.Vm.sharedTypenameToTypeList["stringlike"])) == len(containerType) {
			if indexType.isOnlyCloneOf(cp.Vm, values.INT) {
				cp.put(Idxs, container, index, errTok)
				rtnTypes = AltType(values.ERROR, values.RUNE)
				break
			}
			if indexType.isOnlyCloneOf(cp.Vm, values.PAIR) {
				cp.put(Slis, container, index, errTok)
				rtnTypes = AltType(values.ERROR, values.STRING)
				break
			}
			if indexType.cannotBeACloneOf(cp.Vm, values.INT, values.PAIR) {
				cp.P.Throw("comp/index/string", node.GetToken())
				break
			}

		}
		if containerType.containsOnlyTuples() {
			if indexType.isOnlyCloneOf(cp.Vm, values.INT) {
				cp.put(IdxT, container, index, errTok)
				break
			}
			if indexType.isOnlyCloneOf(cp.Vm, values.PAIR) {
				cp.put(SliT, container, index, errTok)
				break
			}
			if indexType.cannotBeACloneOf(cp.Vm, values.INT, values.PAIR) {
				cp.P.Throw("comp/index/tuple", node.GetToken())
				break
			}
			rtnTypes = cp.getAlternateTypeFromTypeName("any?").Union(AltType(values.ERROR))
		}
		if containerType.isOnlyCloneOf(cp.Vm, values.PAIR) {
			if indexType.isOnlyCloneOf(cp.Vm, values.INT) {
				cp.put(Idxp, container, index, errTok)
				break
			}
			if indexType.cannotBeACloneOf(cp.Vm, values.INT) {
				cp.P.Throw("comp/index/pair", node.GetToken())
				break
			}
			rtnTypes = cp.getAlternateTypeFromTypeName("any?").Union(AltType(values.ERROR))
		}
		if containerType.isOnly(values.TYPE) {
			if indexType.isOnlyCloneOf(cp.Vm, values.INT) {
				cp.put(Idxt, container, index, errTok)
				break
			}
			if indexType.cannotBeACloneOf(cp.Vm, values.INT) {
				cp.P.Throw("comp/index/type", node.GetToken())
				break
			}
			if ctrConst {
				rtnTypes = AltType(values.ERROR, cp.Vm.Mem[container].T)
			} else {
				allEnums := AlternateType{} // TODO --- you only need to calculate this once.
				allEnums = append(allEnums, simpleType(values.ERROR))
				for i := int(values.FIRST_DEFINED_TYPE); i < len(cp.Vm.concreteTypeInfo); i++ {
					if cp.Vm.concreteTypeInfo[i].isEnum() {
						allEnums = append(allEnums, simpleType(i))
					}
				}
				rtnTypes = allEnums
			}
		}
		structT, ok := cp.alternateTypeIsOnlyStruct(containerType)
		if ok {
			structInfo := cp.Vm.concreteTypeInfo[structT].(structType)
			if indexType.isOnly(values.LABEL) {
				if idxConst { // Then we can find the field number of the struct at compile time and throw away the computed label.
					indexNumber := cp.Vm.Mem[index].V.(int)
					labelName := cp.Vm.Labels[indexNumber]
					fieldNumber := structInfo.resolve(indexNumber)
					if fieldNumber == -1 {
						cp.P.Throw("comp/index/struct/a", node.GetToken(), labelName, cp.Vm.DescribeType(structT, LITERAL))
						break
					}
					cp.put(IxZn, container, uint32(fieldNumber))
					rtnTypes = cp.Vm.concreteTypeInfo[structT].(structType).alternateStructFields[fieldNumber]
					break
				}
				cp.put(IxZl, container, index, errTok)
				rtnTypes = AltType()
				for _, t := range cp.Vm.concreteTypeInfo[structT].(structType).alternateStructFields {
					rtnTypes = rtnTypes.Union(t)
				}
				rtnTypes = rtnTypes.Union(AltType(values.ERROR))
				break
			}
			if indexType.isNoneOf(values.LABEL) {
				cp.P.Throw("comp/index/struct/b", node.GetToken())
				break
			}
		}
		if cp.alternateTypeIsOnlyAssortedStructs(containerType) {
			if indexType.isOnly(values.LABEL) {
				if idxConst { // Then we can find the field number of the struct at compile time and throw away the computed label.
					labelIsPossible := false
					labelIsCertain := true
					rtnTypes = AltType()
					for _, structTypeAsSimpleType := range containerType {
						structT := values.ValueType(structTypeAsSimpleType.(simpleType))
						structInfo := cp.Vm.concreteTypeInfo[structT].(structType)
						indexNumber := cp.Vm.Mem[index].V.(int)
						fieldNumber := structInfo.resolve(indexNumber)
						if fieldNumber != -1 {
							labelIsPossible = true
							rtnTypes = rtnTypes.Union(cp.Vm.concreteTypeInfo[structT].(structType).alternateStructFields[fieldNumber])
						} else {
							labelIsCertain = false
						}
					}
					if !labelIsPossible {
						cp.P.Throw("comp/index/struct/c", node.GetToken())
						break
					}
					if !labelIsCertain {
						rtnTypes = rtnTypes.Union(AltType(values.ERROR))
					}
					cp.put(IxZl, container, index, errTok)
					break
				}
				cp.put(IxZl, container, index, errTok)
				break
			}
		}
		// If we can't infer anything else about the types we can emit a catchall indexing operation.
		cp.put(IxXx, container, index, errTok)
		if containerType.Contains(values.TUPLE) {
			rtnTypes = cp.Vm.AnyTypeScheme
		} else {
			rtnTypes = cp.getAlternateTypeFromTypeName("any?")
		}
	case *ast.InfixExpression:
		resolvingCompiler := cp.getResolvingCompiler(node, node.Namespace, ac)
		if resolvingCompiler.P.Infixes.Contains(node.Operator) {
			cp.pushRCompiler(resolvingCompiler)
			rtnTypes, rtnConst = resolvingCompiler.createFunctionCall(cp, node, ctxt.x(), len(node.Namespace) > 0)
			cp.popRCompiler()
			break
		}
		if node.Operator == "," {
			rtnTypes, rtnConst = cp.compileComma(node, ctxt.x())
			break
		}
		cp.P.Throw("comp/known/infix", node.GetToken())
		break
	case *ast.IntegerLiteral:
		cp.Reserve(values.INT, node.Value, node.GetToken())
		rtnTypes, rtnConst = AltType(values.INT), true
		break
	case *ast.LazyInfixExpression:
		if node.Operator == "or" {
			lTypes, lcst := cp.CompileNode(node.Left, ctxt.x())
			if !lTypes.Contains(values.BOOL) {
				cp.P.Throw("comp/bool/or/left", node.GetToken())
				break
			}
			leftRg := cp.That()
			cp.Emit(Qtru, leftRg, cp.Next()+2)
			skipElse := cp.vmGoTo()
			rTypes, rcst := cp.CompileNode(node.Right, ctxt.x())
			if !rTypes.Contains(values.BOOL) {
				cp.P.Throw("comp/bool/or/right", node.GetToken())
				break
			}
			rightRg := cp.That()
			cp.vmComeFrom(skipElse)
			cp.put(Orb, leftRg, rightRg)
			rtnTypes, rtnConst = AltType(values.BOOL), lcst && rcst
			break
		}
		if node.Operator == "and" {
			lTypes, lcst := cp.CompileNode(node.Left, ctxt.x())
			if !lTypes.Contains(values.BOOL) {
				cp.P.Throw("comp/bool/and/left", node.GetToken())
				break
			}
			leftRg := cp.That()
			checkLhs := cp.vmIf(Qtru, leftRg)
			rTypes, rcst := cp.CompileNode(node.Right, ctxt.x())
			if !rTypes.Contains(values.BOOL) {
				cp.P.Throw("comp/bool/and/right", node.GetToken())
				break
			}
			rightRg := cp.That()
			cp.vmComeFrom(checkLhs)
			cp.put(Andb, leftRg, rightRg)
			rtnTypes, rtnConst = AltType(values.BOOL), lcst && rcst
			break
		}
		if node.Operator == ":" {
			if node.Left.GetToken().Type == token.ELSE {
				if cp.loggingOn(ctxt) {
					cp.track(trELSE, &node.Token)
				}
				rtnTypes, rtnConst = cp.CompileNode(node.Right, ctxt)
				break
			}
			if cp.loggingOn(ctxt) {
				cp.track(trCONDITION, &node.Token, cp.P.PrettyPrint(node.Left))
			}
			lTypes, lcst := cp.CompileNode(node.Left, ctxt.x())
			if !lTypes.Contains(values.BOOL) {
				cp.P.Throw("comp/bool/cond/a", node.GetToken())
				break
			}
			// TODO --- what if it's not *only* bool?
			if cp.loggingOn(ctxt) {
				cp.track(trRESULT, &node.Token, cp.That())
			}
			leftRg := cp.That()
			checkLhs := cp.vmIf(Qtru, leftRg)
			rTypes, rcst := cp.CompileNode(node.Right, ctxt)
			ifCondition := cp.vmEarlyReturn(cp.That())
			cp.vmComeFrom(checkLhs)
			cp.put(Asgm, values.C_U_OBJ)
			cp.vmComeFrom(ifCondition)
			rtnTypes, rtnConst = rTypes.Union(AltType(values.UNSATISFIED_CONDITIONAL)), lcst && rcst
			break
		}
		if node.Operator == ";" {
			lTypes, lcst := cp.CompileNode(node.Left, ctxt)
			leftRg := cp.That()
			// We deal with the case where the newline is separating local constant definitions
			// in the 'given' block.
			if lTypes.isOnly(values.CREATED_THUNK_OR_CONST) {
				_, cst := cp.CompileNode(node.Right, ctxt)
				rtnTypes, rtnConst = AltType(values.CREATED_THUNK_OR_CONST), lcst && cst
				break
			}
			// We may be executing a command.
			cmdRet := lTypes.IsLegalCmdReturn()
			if !cmdRet && !lTypes.Contains(values.UNSATISFIED_CONDITIONAL) {
				// TODO --- implement warnings.
				// cp.p.Throw("comp/unreachable", node.GetToken())
				// break
			}
			var rTypes AlternateType
			var rcst bool
			if cmdRet { // It could be error, break, OK, or an unsatisfied conditional.
				ifError := bkEarlyReturn(DUMMY)
				ifCouldBeUnsatButIsnt := bkEarlyReturn(DUMMY)
				if lTypes.Contains(values.ERROR) {
					ifError = cp.vmConditionalEarlyReturn(Qtyp, leftRg, uint32(values.ERROR), leftRg)
				}
				if lTypes.Contains(values.UNSATISFIED_CONDITIONAL) { // Then it is an else-less conditional or a try, and it it isn't UNSAT then we should skip the right node.
					ifCouldBeUnsatButIsnt = cp.vmConditionalEarlyReturn(Qntp, leftRg, uint32(values.UNSATISFIED_CONDITIONAL), leftRg)
				}
				rTypes, _ = cp.CompileNode(node.Right, ctxt) // In a cmd we wish rConst to remain false to avoid folding.
				cp.vmComeFrom(ifError, ifCouldBeUnsatButIsnt)
				rtnTypes, rtnConst = lTypes.Union(rTypes), lcst && rcst

				break
			} else { // Otherwise it's functional.
				satJump := cp.vmIf(Qsat, leftRg)
				lhsIsSat := cp.vmEarlyReturn(leftRg)
				cp.vmComeFrom(satJump)
				rTypes, rcst = cp.CompileNode(node.Right, ctxt)
				cp.put(Asgm, cp.That())
				cp.vmComeFrom(lhsIsSat)
				rtnConst = lcst && rcst
				if !(lTypes.Contains(values.UNSATISFIED_CONDITIONAL) && rTypes.Contains(values.UNSATISFIED_CONDITIONAL)) {
					rtnTypes = lTypes.Union(rTypes).without(tp(values.UNSATISFIED_CONDITIONAL))
				} else {
					rtnTypes = lTypes.Union(rTypes)
				}
				break
			}
		}
	case *ast.ListExpression:
		var containedTypes AlternateType
		errCheck := bkEarlyReturn(DUMMY)
		containedTypes, rtnConst = cp.CompileNode(node.List, ctxt.x())
		if containedTypes.isOnly(values.ERROR) {
			cp.P.Throw("comp/list/err", node.GetToken())
			break
		}
		if containedTypes.Contains(values.ERROR) {
			errCheck = cp.vmConditionalEarlyReturn(Qtyp, cp.That(), uint32(values.ERROR), cp.That())
		}
		cp.put(List, cp.That())
		cp.vmComeFrom(errCheck)
		rtnTypes = AltType(values.LIST)
		break
	case *ast.LogExpression:
		newCtxt := ctxt
		ifRuntimeError := bkEarlyReturn(DUMMY)
		if cp.getLoggingScope() != 0 { // Test that the logging hasn't been silenced by setting '$logging = $OFF'.
			rtnConst = false // Since a log expression has a side-effect, it can't be folded even if it's constant.
			// A a user-defined logging statement can contain arbitrary expressions in the |...| delimiters which we
			// therefore need to compile like it was a snippet.
			if node.Value == "" {
				newCtxt.logFlavor = LF_AUTO
			} else {
				newCtxt.logFlavor = LF_MANUAL
				logCheck := cp.vmIf(Qlog) // Skips over the logging if we are already in a logging statement, as explained below.
				cp.Emit(Logn)             // 'logn' and 'logy' turn logging on and off respectively in the vm, to prevent us from logging the activities of functions called in compileLog and at worst facing an infinite regress.
				outputLoc, logMayHaveError := cp.compileLog(node, ctxt)
				cp.track(trLITERAL, &node.Token, outputLoc)
				cp.Emit(Logy)
				if logMayHaveError {
					ifRuntimeError = cp.vmConditionalEarlyReturn(Qtyp, outputLoc, uint32(values.ERROR), cp.That())
				}
				cp.vmComeFrom(logCheck)
			}
		}
		// Syntactically a log expression is attached to a normal expression, which we must now compile.
		switch node.GetToken().Type {
		case token.IFLOG:
			// This unDRY-ly repeats a bunch of the logic for generating a conditiona. TODO? We could consider factoring it out but it would be messy to save only a few duplicated lines.
			if node.Left.GetToken().Type == token.ELSE {
				rtnTypes, _ = cp.CompileNode(node.Right, ctxt)
				break
			}

			lTypes, _ := cp.CompileNode(node.Left, ctxt.x())
			if !lTypes.Contains(values.BOOL) {
				cp.P.Throw("comp/bool/cond/b", node.GetToken())
				break
			}
			// TODO --- what if it's not *only* bool?
			leftRg := cp.That()
			checkLhs := cp.vmIf(Qtru, leftRg)
			rTypes, _ := cp.CompileNode(node.Right, ctxt)
			ifCondition := cp.vmEarlyReturn(cp.That())
			cp.vmComeFrom(checkLhs)
			cp.put(Asgm, values.C_U_OBJ)
			cp.vmComeFrom(ifCondition)
			rtnTypes = rTypes.Union(AltType(values.UNSATISFIED_CONDITIONAL))
			break
		case token.PRELOG:
			rtnTypes, _ = cp.CompileNode(node.Right, ctxt)
		default: // I.e. token.LOG.
			rtnTypes, _ = cp.CompileNode(node.Left, newCtxt)
		}
		cp.vmComeFrom(ifRuntimeError)
		break
	case *ast.Nothing:
		cp.put(Asgm, values.C_EMPTY_TUPLE)
		rtnTypes, rtnConst = AlternateType{finiteTupleType{}}, true
	case *ast.PipingExpression: // I.e. -> >> and -> and ?> .
		lhsTypes, lhsConst := cp.CompileNode(node.Left, ctxt.x())
		if cp.P.ErrorsExist() {
			break
		}
		// And that's about all the streaming operators really do have in common under the hood, so let's do a switch on the operators.
		var rhsConst bool
		switch node.Operator {
		case "->":
			rtnTypes, rhsConst = cp.compilePipe(lhsTypes, lhsConst, node.Right, env, ctxt)
		case ">>":
			rtnTypes, rhsConst = cp.compileMappingOrFilter(lhsTypes, lhsConst, node.Right, env, ctxt, false)
		default:
			rtnTypes, rhsConst = cp.compileMappingOrFilter(lhsTypes, lhsConst, node.Right, env, ctxt, true)
		}
		rtnConst = lhsConst && rhsConst
		break
	case *ast.PrefixExpression: // Note that the vmmaker will have caught xcall and builtin expressions already.
		if node.Token.Type == token.NOT {
			allTypes, cst := cp.CompileNode(node.Args[0], ctxt.x())
			switch {
			case allTypes.isOnly(values.BOOL):
				cp.put(Notb, cp.That())
				rtnTypes, rtnConst = AltType(values.BOOL), cst
				break NodeTypeSwitch
			case allTypes.Contains(values.BOOL):
				boolTest := cp.vmIf(Qtyp, cp.That(), uint32(values.FUNC))
				cp.put(Notb, cp.That())
				cp.Emit(Jmp, cp.CodeTop()+2)
				cp.vmComeFrom(boolTest)
				cp.Emit(Asgm, cp.That(), cp.reserveError("vm/bool/not", node.GetToken()))
				rtnTypes, rtnConst = AltType(values.ERROR, values.BOOL), cst
				break NodeTypeSwitch
			default:
				cp.P.Throw("comp/bool/not", node.GetToken())
				rtnTypes, rtnConst = AltType(values.COMPILE_TIME_ERROR), false
				break NodeTypeSwitch
			}
		}
		if node.Token.Type == token.VALID {
			_, rtnConst = cp.CompileNode(node.Args[0], ctxt.x())
			cp.put(Vlid, cp.That())
			rtnTypes = AltType(values.BOOL)
			break
		}
		if node.Token.Type == token.UNWRAP {
			_, rtnConst = cp.CompileNode(node.Args[0], ctxt.x())
			errTok := cp.reserveToken(node.GetToken())
			cp.put(Uwrp, cp.That(), errTok)
			rtnTypes = AltType(values.ERROR).Union(cp.getAlternateTypeFromTypeName("Error"))
			break
		}
		if node.Token.Type == token.GLOBAL { // This is in effect a compiler directive, it doesn't need to emit any code besides `ok`, it just mutates the environment.
			for _, v := range node.Args {
				switch arg := v.(type) {
				case *ast.Identifier:
					variable, ok := cp.GlobalVars.getVar(arg.Value)
					if !ok {
						cp.P.Throw("comp/global/global", arg.GetToken())
						break NodeTypeSwitch
					}
					env.data[arg.Value] = *variable
				default:
					cp.P.Throw("comp/global/ident", arg.GetToken())
					break NodeTypeSwitch
				}
			}
			rtnTypes, rtnConst = AltType(values.SUCCESSFUL_VALUE), false
			break
		}
		if node.Token.Type == token.BREAK {
			if !cp.forDataExists() { // Then we're not in a 'for' loop.
				cp.P.Throw("comp/break", node.GetToken())
				break NodeTypeSwitch
			}
			rtnTypes, rtnConst = cp.CompileNode(node.Args[0], ctxt)
			cp.addToForData(cp.vmBreakWithValue(cp.That()))
			break
		}
		resolvingCompiler := cp.getResolvingCompiler(node, node.Namespace, ac)
		if cp.P.ErrorsExist() {
			break
		}
		var (
			v  *variable
			ok bool
		)
		if resolvingCompiler != cp {
			v, ok = resolvingCompiler.GlobalConsts.getVar(node.Operator)
		} else {
			v, ok = env.getVar(node.Operator)
		}
		if ok { // Then it is a variable which may contain a function which may or may not be wrapped in a thunk.
			cp.cm("Prefix is variable which may contain a lambda.", node.GetToken())
			recursion := false
			if v.access == LOCAL_FUNCTION_THUNK || v.access == LOCAL_FUNCTION_CONSTANT {
				if cp.Vm.Mem[v.mLoc].V == nil { // Then it's uninitialized because we're doing recursion in a given block and we haven't compiled that function yet.
					cp.Emit(Rpsh, cp.getLambdaStart(), cp.MemTop())
					recursion = true
				}
			}
			if v.access == LOCAL_VARIABLE_THUNK || v.access == LOCAL_FUNCTION_THUNK {
				cp.cm("Prefix variable is thunked. Unthunking.", node.GetToken())
				cp.Emit(Untk, v.mLoc)
			}
			operands := []uint32{v.mLoc}
			for _, arg := range node.Args {
				cp.CompileNode(arg, ctxt.x())
				operands = append(operands, cp.That())
			}
			if cp.P.ErrorsExist() {
				break NodeTypeSwitch
			}
			switch {
			case v.types.isOnly(values.FUNC):
				cp.cm("Prefix variable can only be lambda.", node.GetToken())
				cp.put(Dofn, operands...)
				if recursion {
					cp.Emit(Rpop)
				}
			case v.types.Contains(values.FUNC):
				errorLoc := cp.reserveError("vm/apply/func", node.GetToken())
				cp.cm("Prefix variable might be lambda. Emitting type check.", node.GetToken())
				funcTest := cp.vmIf(Qtyp, v.mLoc, uint32(values.FUNC))
				cp.put(Dofn, operands...)
				if recursion {
					cp.Emit(Rpop)
				}
				cp.Emit(Jmp, cp.CodeTop()+2)
				cp.vmComeFrom(funcTest)
				cp.Emit(Asgm, cp.That(), errorLoc)
			default:
				cp.cm("Prefix variable cannot be lambda. Throwing error.", node.GetToken())
				cp.P.Throw("comp/apply/func", node.GetToken())
				break NodeTypeSwitch
			}
			rtnConst = false
			rtnTypes = cp.Vm.AnyTypeScheme
			break NodeTypeSwitch
		}
		if resolvingCompiler.P.Prefixes.Contains(node.Operator) || resolvingCompiler.P.Functions.Contains(node.Operator) {
			cp.pushRCompiler(resolvingCompiler)
			rtnTypes, rtnConst = resolvingCompiler.createFunctionCall(cp, node, ctxt.x(), len(node.Namespace) > 0)
			cp.popRCompiler()
			break
		}
		cp.P.Throw("comp/known/prefix", node.GetToken())
		break
	case *ast.RuneLiteral:
		cp.Reserve(values.RUNE, node.Value, node.GetToken())
		rtnTypes, rtnConst = AltType(values.RUNE), true
		break
	case *ast.StringLiteral:
		cp.Reserve(values.STRING, node.Value, node.GetToken())
		rtnTypes, rtnConst = AltType(values.STRING), true
		break
	case *ast.StructExpression:
		panic("This is used only in the vmmaker and should never be compiled.")
	case *ast.SuffixExpression:
		resolvingCompiler := cp.getResolvingCompiler(node, node.Namespace, ac)
		if node.GetToken().Type == token.EMDASH {
			switch t := node.Args[0].(type) {
			case *ast.TypeLiteral:
				snF := cp.reserveSnippetFactory(t.Value, env, node, ctxt)
				cp.put(MkSn, snF)
				rtnTypes, rtnConst = cp.typeNameToTypeScheme[t.Value], false
				break NodeTypeSwitch
			default:
				cp.P.Throw("comp/snippet/type", node.Args[0].GetToken()) // There is no reason why this should be a first-class value, that would just be confusing. Hence the error.
				break NodeTypeSwitch
			}
		}
		if node.GetToken().Type == token.DOTDOTDOT {
			if len(node.Args) != 1 {
				cp.P.Throw("comp/splat/args", node.GetToken())
				break NodeTypeSwitch
			}
			var leftTypes AlternateType
			leftTypes, rtnConst = cp.CompileNode(node.Args[0], ctxt.x())
			overlap := leftTypes.intersect(cp.Vm.sharedTypenameToTypeList["listlike"])
			if len(overlap) == 0 {
				cp.P.Throw("comp/splat/types", node.GetToken(), leftTypes)
				rtnTypes = altType(values.COMPILE_TIME_ERROR)
				break NodeTypeSwitch
			}
			if len(leftTypes) == len(overlap) {
				cp.put(TupL, cp.That())
				rtnTypes = altType(values.TUPLE)
				break NodeTypeSwitch
			}
			cp.put(TuLx, cp.That(), cp.reserveToken(node.Args[0].GetToken()))
			rtnTypes = altType(values.ERROR, values.TUPLE)
			break NodeTypeSwitch
		}
		if resolvingCompiler.P.Suffixes.Contains(node.Operator) {
			cp.pushRCompiler(resolvingCompiler)
			rtnTypes, rtnConst = resolvingCompiler.createFunctionCall(cp, node, ctxt.x(), len(node.Namespace) > 0)
			cp.popRCompiler()
			break
		}
		cp.P.Throw("comp/known/suffix", node.GetToken())
		break
	case *ast.TryExpression:
		ident := node.VarName
		v, exists := env.getVar(ident)
		if exists && (v.access == GLOBAL_CONSTANT_PRIVATE || v.access == GLOBAL_CONSTANT_PUBLIC || v.access == GLOBAL_VARIABLE_PRIVATE ||
			v.access == GLOBAL_VARIABLE_PUBLIC || v.access == LOCAL_VARIABLE_THUNK || v.access == LOCAL_FUNCTION_THUNK) {
			cp.P.Throw("comp/try/var", node.GetToken())
			break
		}
		var err uint32
		if !exists {
			err = cp.Reserve(values.NULL, nil, node.GetToken())
			cp.AddVariable(env, ident, LOCAL_VARIABLE, AltType(values.NULL, values.ERROR), node.GetToken())
		} else {
			err = v.mLoc
		}
		tryTypes, _ := cp.CompileNode(node.Right, ctxt.x())
		if tryTypes.isNoneOf(values.ERROR, values.SUCCESSFUL_VALUE) {
			cp.P.Throw("comp/try/return", node.GetToken())
			break
		}
		cp.Emit(Qtyp, cp.That(), uint32(values.ERROR), cp.CodeTop()+4)
		cp.Emit(Asgm, err, cp.That())
		cp.Emit(Asgm, cp.That(), values.C_U_OBJ)
		cp.Emit(Qtyp, cp.That(), uint32(values.ERROR), cp.CodeTop()+2)
		cp.Emit(Asgm, cp.That(), values.C_OK)
		rtnTypes, rtnConst = AltType(values.UNSATISFIED_CONDITIONAL, values.SUCCESSFUL_VALUE), false
		break
	case *ast.TypeLiteral:
		resolvingCompiler := cp.getResolvingCompiler(node, node.Namespace, ac)
		typeName := node.Value
		switch { // We special-case it a bit because otherwise a string would look like a varchar(0).
		case typeName == "string":
			cp.Reserve(values.TYPE, values.AbstractType{[]values.ValueType{values.STRING}, DUMMY}, node.GetToken())
		case typeName == "string?":
			cp.Reserve(values.TYPE, values.AbstractType{[]values.ValueType{values.NULL, values.STRING}, DUMMY}, node.GetToken())
		default:
			abType := resolvingCompiler.P.GetAbstractType(typeName)
			if (ac == REPL || resolvingCompiler != cp) && cp.isPrivate(abType) {
				cp.P.Throw("comp/private/type", node.GetToken())
			}
			cp.Reserve(values.TYPE, abType, node.GetToken())
		}
		rtnTypes, rtnConst = AltType(values.TYPE), true
		break
	case *ast.UnfixExpression:
		resolvingCompiler := cp.getResolvingCompiler(node, node.Namespace, ac)
		if resolvingCompiler.P.Unfixes.Contains(node.Operator) {
			rtnTypes, rtnConst = resolvingCompiler.createFunctionCall(resolvingCompiler, node, ctxt.x(), len(node.Namespace) > 0)
			break
		}
		cp.P.Throw("comp/known/unfix", node.GetToken()) // TODO --- can errors like this even arise or must they be caught in the parser?
		break
	default:
		panic("Unimplemented node type " + reflect.TypeOf(node).String() + " at line " + strconv.Itoa(node.GetToken().Line) + " of " + node.GetToken().Source)
	}
	// We're done with the typeswitch. We perform some sanity checks to ensure that our functions aren't behaving
	// like commands or vice versa.
	if !rtnTypes.IsLegalCmdReturn() && !rtnTypes.IsLegalDefReturn() && !rtnTypes.Contains(values.COMPILE_TIME_ERROR) {
		cp.P.Throw("comp/sanity", node.GetToken())
	}
	if ac == DEF && !rtnTypes.IsLegalDefReturn() {
		cp.P.Throw("comp/fcis", node.GetToken())
	}
	if cp.P.ErrorsExist() {
		return AltType(values.COMPILE_TIME_ERROR), true
	}
	// If the node we evaluated is potentially a return value of a function we're compiling, then
	// if the function has return types this is where we can check if they've been violated.
	if ctxt.isReturn {
		cp.checkInferredTypesAgainstContext(rtnTypes, ctxt.typecheck, node.GetToken())
	}
	if cp.P.ErrorsExist() {
		return AltType(values.COMPILE_TIME_ERROR), true
	}
	// We do a little logging.
	if cp.loggingOn(ctxt) && ac == DEF {
		_, isLazyInfix := node.(*ast.LazyInfixExpression)
		_, isLoggingOperation := node.(*ast.LogExpression)
		if !(isLazyInfix || isLoggingOperation) {
			cp.track(trRETURN, node.GetToken(), ctxt.fName, cp.That())
			return rtnTypes, false // 'false' because we don't want to fold away the tracking information.
		}
	}
	// If we have a foldable constant, we run the code, roll back the vm, and put the result we got
	// from the code on top of memory.
	if rtnConst && (!rtnTypes.hasSideEffects()) && cp.CodeTop() > cT {
		cp.Emit(Ret)
		cp.cm("Calling Run from end of CompileNode as part of routine constant folding.", node.GetToken())
		cp.Vm.Run(cT)
		result := cp.Vm.Mem[cp.That()]
		if result.T == values.TUPLE {
			tType := finiteTupleType{}
			for _, v := range result.V.([]values.Value) {
				tType = append(tType, simpleType(v.T))
			}
			rtnTypes = AlternateType{tType}
		} else {
			rtnTypes = AltType(result.T)
		}
		cp.rollback(state, node.GetToken())
		cp.Reserve(result.T, result.V, node.GetToken())
	}
	// We return the range of types we inferred as the result of the node, as an AlternateType typescheme,
	// and whether or not the result is a constant.
	return rtnTypes, rtnConst
}

// A function auxiliary to the previous one that checks the return types of a function.
func (cp *Compiler) checkInferredTypesAgainstContext(rtnTypes AlternateType, typecheck finiteTupleType, tok *token.Token) {
	if typecheck == nil {
		return
	}
	typeLengths := lengths(rtnTypes)
	if !(typeLengths.Contains(-1) || typeLengths.Contains(len(typecheck))) {
		cp.P.Throw("comp/return/length", tok, rtnTypes.describe(cp.Vm), typecheck.describe(cp.Vm))
		return
	}
	for i, ty := range typecheck {
		intersection := ty.(AlternateType).intersect(typesAtIndex(rtnTypes, i))
		if len(intersection) == 0 {
			cp.P.Throw("comp/return/types", tok, rtnTypes.without(simpleType(values.ERROR)).describe(cp.Vm), typecheck.describe(cp.Vm))
		}
	}
}

// Function auxiliary to CompileNode that finds the appropriate compiler for a given namespace.
func (cp *Compiler) getResolvingCompiler(node ast.Node, namespace []string, ac cpAccess) *Compiler {
	lC := cp
	for _, name := range namespace {
		srv, ok := lC.Services[name]
		if !ok {
			cp.P.Throw("comp/namespace/exist", node.GetToken(), name)
			return nil
		}
		lC = srv.Cp
		if lC.P.Private && (ac == REPL || len(namespace) > 1) {
			cp.P.Throw("comp/namespace/private", node.GetToken(), name)
			return nil
		}
	}
	return lC
}

// This function compiles a comma, i.e. the thing that concatenates values into tuples.
// This needs its own very special logic because the typescheme it returns has to be composed in a different
// way from all the other operators.
func (cp *Compiler) compileComma(node *ast.InfixExpression, ctxt context) (AlternateType, bool) {
	lTypes, lcst := cp.CompileNode(node.Args[0], ctxt.x())
	if lTypes.isOnly(values.ERROR) {
		cp.P.Throw("comp/tuple/err/a", node.GetToken())
	}
	left := cp.That()
	rTypes, rcst := cp.CompileNode(node.Args[2], ctxt.x())
	if rTypes.isOnly(values.ERROR) {
		cp.P.Throw("comp/tuple/err/b", node.GetToken())
	}
	right := cp.That()
	leftIsError := bkEarlyReturn(DUMMY)
	rightIsError := bkEarlyReturn(DUMMY)
	if lTypes.Contains(values.ERROR) {
		leftIsError = cp.vmConditionalEarlyReturn(Qtyp, left, uint32(tp(values.ERROR)), left)
	}
	if rTypes.Contains(values.ERROR) {
		rightIsError = cp.vmConditionalEarlyReturn(Qtyp, right, uint32(tp(values.ERROR)), right)
	}
	leftMustBeSingle, leftMustBeTuple := lTypes.mustBeSingleOrTuple()
	rightMustBeSingle, rightMustBeTuple := rTypes.mustBeSingleOrTuple()
	switch {
	case leftMustBeSingle && rightMustBeSingle:
		cp.put(Cc11, left, right)
	case leftMustBeSingle && rightMustBeTuple:
		cp.put(Cc1T, left, right)
	case leftMustBeTuple && rightMustBeSingle:
		cp.put(CcT1, left, right)
	case leftMustBeTuple && rightMustBeTuple:
		cp.put(CcTT, left, right)
	default:
		cp.put(Ccxx, left, right) // We can after all let the operation dispatch for us.
	}
	cp.vmComeFrom(leftIsError, rightIsError)
	lT := lTypes.reduce()
	rT := rTypes.reduce()
	cst := lcst && rcst
	switch lT := lT.(type) {
	case finiteTupleType:
		switch rT := rT.(type) {
		case finiteTupleType:
			return AlternateType{append(lT, rT...)}, cst
		case TypedTupleType:
			return AlternateType{TypedTupleType{rT.T.Union(getAllTypes(lT))}}, cst
		case simpleType:
			return AlternateType{finiteTupleType{append(lT, rT)}}, cst
		case AlternateType:
			return AlternateType{finiteTupleType{append(lT, rT)}}, cst // TODO --- check if this works.
		default:
			panic("We shouldn't be here!")
		}
	case TypedTupleType:
		switch rT := rT.(type) {
		case finiteTupleType:
			return AlternateType{TypedTupleType{lT.T.Union(getAllTypes(rT))}}, cst
		case TypedTupleType:
			return AlternateType{TypedTupleType{lT.T.Union(rT.T)}}, cst
		case simpleType:
			return AlternateType{TypedTupleType{lT.T.Union(AlternateType{rT})}}, cst
		case AlternateType:
			return AlternateType{TypedTupleType{lT.T.Union(getAllTypes(rT))}}, cst
		default:
			panic("We shouldn't be here!")
		}
	case simpleType:
		switch rT := rT.(type) {
		case finiteTupleType:
			return AlternateType{append(finiteTupleType{lT}, rT...)}, cst
		case TypedTupleType:
			return AlternateType{TypedTupleType{rT.T.Union(AlternateType{lT})}}, cst
		case simpleType:
			return AlternateType{finiteTupleType{lT, rT}}, cst
		case AlternateType:
			return AlternateType{finiteTupleType{lT, rT}}, cst
		default:
			panic("We shouldn't be here!")
		}
	case AlternateType:
		switch rT := rT.(type) {
		case finiteTupleType:
			return AlternateType{append(finiteTupleType{lT}, rT...)}, cst
		case TypedTupleType:
			return AlternateType{TypedTupleType{rT.T.Union(lT)}}, cst
		case simpleType:
			return AlternateType{finiteTupleType{lT, rT}}, cst
		case AlternateType:
			return AlternateType{finiteTupleType{lT, rT}}, cst
		default:
			panic("We shouldn't be here!")
		}
	default:
		panic("We shouldn't be here!")
	}
}

// A type to support the following function.
type loopFlavor int

const (
	UNDEFINED_LOOP_FLAVOR loopFlavor = iota
	TRIPARTITE
	WHILE
	INFINITE_LOOP
	RANGE
)

// Compiles the various flavors of `for` loop.
// We have four cases.
// (i) The 'for' loop has a C-like tripartite header.
// (ii) The 'for' loop is acting as a 'while' loop and so just has a conditional.
// (iii) It doesn't even have a conditional, and can be exited only with break.
// (iv) The 'for' loop is of the form x::y = range z
func (cp *Compiler) compileForExpression(node *ast.ForExpression, ctxt context) AlternateType {
	tok := &node.Token
	cp.cm("Called compileForExpression", tok)
	// The 'flavor' flag allows us to keep track of what kind of `for` loop we're compiling.
	flavor := UNDEFINED_LOOP_FLAVOR
	hasBoundVariables := false
	var keysOnly, valuesOnly bool     // Only applies to range-style loops.
	rangeKeyLoc := uint32(DUMMY)      //          "
	rangeValLoc := uint32(DUMMY)      //          "
	iteratorLoc := uint32(DUMMY)      //          "
	rangeOver := bkEarlyReturn(DUMMY) //      "

	// The parser so far has only broken the header up into its parts, but has not validated
	// that they're in the proper form.

	newEnv := &Environment{map[string]variable{}, ctxt.env}
	newContext := ctxt.x()
	newContext.env = newEnv

	// First we set up the bound variables.

	boundResultLoc := uint32(DUMMY)
	indexResultLoc := uint32(DUMMY)
	var boundCpSig, indexCpSig cpSig
	var boundVariableTypes, indexVariableTypes AlternateType

	if node.BoundVariables == nil {
		if ctxt.access != CMD && ctxt.access != REPL {
			cp.P.Throw("cp/for/bound/a", &node.Token)
			return altType(values.COMPILE_TIME_ERROR)
		}
		cp.Reserve(values.UNDEFINED_VALUE, nil, node.BoundVariables.GetToken()) // If we don't have any bound variables, then this is presumptively an imperative loop and we'll need somewhere to put OK/break/error still.
		boundResultLoc = cp.That()
	} else {
		hasBoundVariables = true
		// We set up the bound variables. Note that type checking happens *inside* the 'for' loop, not up here.
		if node.BoundVariables.GetToken().Type != token.ASSIGN {
			cp.P.Throw("cp/for/bound/b", &node.Token)
			return altType(values.COMPILE_TIME_ERROR)
		}
		lhsOfBoundVariables := node.BoundVariables.(*ast.AssignmentExpression).Left
		rhsOfBoundVariables := node.BoundVariables.(*ast.AssignmentExpression).Right
		boundSig, err := cp.P.RecursivelySlurpSignature(lhsOfBoundVariables, "*default*")
		if err != nil {
			cp.P.Throw("comp/for/bound/c", node.BoundVariables.GetToken())
			return altType(values.COMPILE_TIME_ERROR)
		}
		cp.cm("Finding intitial values of bound variables", tok)
		var isConst bool
		boundVariableTypes, isConst = cp.CompileNode(rhsOfBoundVariables, ctxt)
		if isConst { // Then we still need to initialize the index variables when we start the loop.
			cp.put(Asgm, cp.That())
		}
		boundResultLoc = cp.That()
		if cp.P.ErrorsExist() {
			return altType(values.COMPILE_TIME_ERROR)
		}
		for i, pair := range boundSig {
			_, exists := newEnv.getVar(pair.VarName)
			if exists {
				cp.P.Throw("comp/for/bound/exists", node.BoundVariables.GetToken())
				return altType(values.COMPILE_TIME_ERROR)
			}
			cp.Reserve(values.UNDEFINED_VALUE, nil, tok)
			var types AlternateType
			if pair.VarType == "*default*" {
				types = typesAtIndex(boundVariableTypes, i)
			} else {
				types = cp.getAlternateTypeFromTypeName(pair.VarType)
			}
			cp.AddVariable(newEnv, pair.VarName, FOR_LOOP_BOUND_VARIABLE, types, tok)
			boundCpSig = append(boundCpSig, NameAlternateTypePair{pair.VarName, types})
		}
	}

	// Now the variables for the header, if any.
	switch {
	case node.Initializer != nil: // Then we have a C-like tripartite header.
		flavor = TRIPARTITE
		// For the initializer we have to do something very un-DRYly like what we just did with the bound variables; TODO ---
		// is there any way to DRY it up that doesn't obfuscate the code?
		if node.Initializer.GetToken().Type != token.ASSIGN {
			cp.P.Throw("cp/for/init/a", &node.Token)
			return altType(values.COMPILE_TIME_ERROR)
		}
		lhsOfInitVariables := node.Initializer.(*ast.AssignmentExpression).Left
		rhsOfInitVariables := node.Initializer.(*ast.AssignmentExpression).Right
		indexSig, err := cp.P.RecursivelySlurpSignature(lhsOfInitVariables, "*default*")
		if err != nil {
			cp.P.Throw("comp/for/init/b", node.Initializer.GetToken())
			return altType(values.COMPILE_TIME_ERROR)
		}
		cp.cm("Finding intitial values of index variables", tok)
		var isConst bool
		indexVariableTypes, isConst = cp.CompileNode(rhsOfInitVariables, ctxt)
		if isConst { // Then we still need to initialize the index variables when we start the loop.
			cp.put(Asgm, cp.That())
		}
		indexResultLoc = cp.That()
		if cp.P.ErrorsExist() {
			return altType(values.COMPILE_TIME_ERROR)
		}
		for i, pair := range indexSig {
			_, exists := newEnv.getVar(pair.VarName)
			if exists {
				cp.P.Throw("comp/for/index/exists", node.Initializer.GetToken())
				return altType(values.COMPILE_TIME_ERROR)
			}
			cp.Reserve(values.UNDEFINED_VALUE, nil, tok)
			var types AlternateType
			if pair.VarType == "*default*" {
				types = typesAtIndex(indexVariableTypes, i)
			} else {
				types = cp.getAlternateTypeFromTypeName(pair.VarType)
			}
			cp.AddVariable(newEnv, pair.VarName, FOR_LOOP_INDEX_VARIABLE, types, tok)
			indexCpSig = append(indexCpSig, NameAlternateTypePair{pair.VarName, types})
		}
	case node.ConditionOrRange == nil:
		flavor = INFINITE_LOOP
	case node.ConditionOrRange.GetToken().Type == token.ASSIGN: // Then we should have a 'range' expression, which we can deconstruct.
		flavor = RANGE
		pairOfIdentifiers := node.ConditionOrRange.(*ast.AssignmentExpression).Left
		rangeExpression := node.ConditionOrRange.(*ast.AssignmentExpression).Right
		if pairOfIdentifiers, ok := pairOfIdentifiers.(*ast.InfixExpression); ok && pairOfIdentifiers.Operator == "::" {
			var leftName, rightName string
			if leftId, ok := pairOfIdentifiers.Args[0].(*ast.Identifier); ok {
				leftName = leftId.Value
			} else {
				cp.P.Throw("comp/for/range/a", node.GetToken())
				return altType(values.COMPILE_TIME_ERROR)
			}
			if rightId, ok := pairOfIdentifiers.Args[2].(*ast.Identifier); ok {
				rightName = rightId.Value
			} else {
				cp.P.Throw("comp/for/range/b", node.GetToken())
				return altType(values.COMPILE_TIME_ERROR)
			}
			keysOnly = rightName == "_"
			valuesOnly = leftName == "_"
			if keysOnly && valuesOnly {
				cp.P.Throw("comp/for/range/discard", node.GetToken())
				return altType(values.COMPILE_TIME_ERROR)
			}
			var rangeOver ast.Node
			if rangeExpression, ok := rangeExpression.(*ast.PrefixExpression); ok && rangeExpression.Operator == "range" {
				rangeOver = rangeExpression.Args[0]
				rangeTypes, _ := cp.CompileNode(rangeOver, ctxt.x())

				if len(rangeTypes.intersect(cp.Vm.IsRangeable)) == 0 && !rangeTypes.Contains(values.TUPLE) { // Note that 'Contains' special-cases tuples.
					cp.P.Throw("comp/for/range/types", node.GetToken())
					return altType(values.COMPILE_TIME_ERROR)
				}
				keysInt := uint32(0)
				if keysOnly {
					keysInt = 1
				}
				cp.put(Mkit, cp.That(), keysInt, cp.reserveToken(rangeOver.GetToken())) // TODO --- optimize constant case.
				iteratorLoc = cp.That()
				if !valuesOnly {
					cp.Reserve(values.UNDEFINED_VALUE, nil, rangeOver.GetToken())
					rangeKeyLoc = cp.That()
					_, exists := newEnv.getVar(leftName)
					if exists {
						cp.P.Throw("comp/for/exists/key", rangeOver.GetToken(), leftName)
						return altType(values.COMPILE_TIME_ERROR)
					}
					cp.AddVariable(newEnv, leftName, FOR_LOOP_INDEX_VARIABLE, cp.getAlternateTypeFromTypeName("any?"), rangeOver.GetToken()) // TODO --- narrow down.
				}
				if !keysOnly {
					cp.Reserve(values.UNDEFINED_VALUE, nil, rangeOver.GetToken())
					rangeValLoc = cp.That()
					_, exists := newEnv.getVar(rightName)
					if exists {
						cp.P.Throw("comp/for/exists/value", rangeOver.GetToken(), rightName)
						return altType(values.COMPILE_TIME_ERROR)
					}
					cp.AddVariable(newEnv, rightName, FOR_LOOP_INDEX_VARIABLE, cp.getAlternateTypeFromTypeName("any?"), rangeOver.GetToken())
				}
			}
		} else {
			cp.P.Throw("comp/for/range/c", node.Initializer.GetToken())
			return altType(values.COMPILE_TIME_ERROR)
		}
	default:
		flavor = WHILE
	} // end of switch

	saveThunkList := cp.ThunkList // TODO --- I really must stop doing that.
	cp.ThunkList = []ThunkData{}

	if node.Given == nil {
		cp.cm("The 'given' block of the 'for' loop is nil.", tok)
	} else {
		jumpOverGiven := cp.vmGoTo() // The 'given' block needs to be compiled here but should of course only have parts executed on demand.
		cp.cm("Compiling the 'given' block of the 'for' loop", tok)
		cp.compileGivenBlock(node.Given, newContext)
		cp.vmComeFrom(jumpOverGiven)
	}

	conditionalFails := bkEarlyReturn(DUMMY)
	startOfForLoop := cp.CodeTop()

	// Typechecking happens here:

	if hasBoundVariables {
		cp.cm("Typechecking bound variable result and putting it into bound variables.", tok)
		cp.emitTypeChecks(boundResultLoc, boundVariableTypes, newEnv, boundCpSig, ctxt.access, tok, typeCheckFlavor(FOR_LOOP_BOUND_VARIABLE))
	}
	if flavor == TRIPARTITE {
		cp.cm("Typechecking index variable result and putting it into index variables.", tok)
		cp.emitTypeChecks(indexResultLoc, indexVariableTypes, newEnv, indexCpSig, ctxt.access, tok, typeCheckFlavor(FOR_LOOP_INDEX_VARIABLE))
	}
	// The conditional for ending the loop, according to the flavor of the loop.
	if flavor == TRIPARTITE || flavor == WHILE {
		cp.cm("Compiling conditional.", tok)
		cp.CompileNode(node.ConditionOrRange, newContext)
		if cp.P.ErrorsExist() {
			return altType(values.COMPILE_TIME_ERROR)
		}
		conditionalFails = cp.vmConditionalEarlyReturn(Qfls, cp.That(), boundResultLoc)
	}
	if flavor == RANGE {
		rangeOver = cp.vmConditionalEarlyReturn(Qitr, iteratorLoc, boundResultLoc)
		switch {
		case keysOnly:
			cp.Emit(Itgk, rangeKeyLoc, iteratorLoc)
		case valuesOnly:
			cp.Emit(Itgv, rangeValLoc, iteratorLoc)
		default:
			cp.Emit(Itkv, rangeKeyLoc, rangeValLoc, iteratorLoc)
		}
	}
	// Now we get to emit the loop body, which is the same whatever the flavor of loop.
	cp.cm("Compiling loop body.", tok)
	cp.pushNewForData()

	cp.cm("Setting up thunks for the locals in the given block, if any.", tok)
	for _, thunk := range cp.ThunkList {
		cp.Emit(Thnk, thunk.dest, thunk.value.MLoc, thunk.value.CAddr)
	}
	cp.ThunkList = saveThunkList

	rtnTypes, _ := cp.CompileNode(node.Body, newContext)
	if cp.P.ErrorsExist() {
		return altType(values.COMPILE_TIME_ERROR)
	}
	cp.Emit(Asgm, boundResultLoc, cp.That())
	// Any 'continue' statements we've emitted are in the compiler's forData.
	cp.resolveContinues()
	// And then the iterator, which again differs according to the flavor.
	if flavor == TRIPARTITE {
		cp.cm("Compiling iterator for loop with tripartite header.", tok)
		cp.CompileNode(node.Update, newContext)
		if cp.P.ErrorsExist() {
			return altType(values.COMPILE_TIME_ERROR)
		}
		cp.Emit(Asgm, indexResultLoc, cp.That())
	}
	// And we jump to the start of the loop.
	cp.cm("Jumping to start of loop again.", tok)
	cp.Emit(Jmp, startOfForLoop)
	// When we break out of the loop, we just need to put the result (in the bound variables) on top of memory.
	cp.cm("Putting result on top of memory.", tok)
	cp.resolveBreaksWithoutValue()
	cp.put(Asgm, boundResultLoc)
	cp.resolveBreaksWithValue()
	cp.vmComeFrom(conditionalFails, rangeOver)

	return rtnTypes
}

// Some auxilliary functiona for the `for` loops.

func (cp *Compiler) pushNewForData() {
	cp.forData = append(cp.forData, []any{})
}

// Takes the continues out of the top of the for stack and resolves them, leaves the breaks.
func (cp *Compiler) resolveContinues() {
	for _, item := range cp.forData[len(cp.forData)-1] {
		if item, ok := item.(bkContinue); ok {
			cp.vmComeFrom(item)
		}
	}
}

// Resolves the plain `break` statements where the loop returns the bound variables.
func (cp *Compiler) resolveBreaksWithoutValue() {
	for _, item := range cp.forData[len(cp.forData)-1] {
		if item, ok := item.(bkBreakWithoutValue); ok {
			cp.vmComeFrom(item)
		}
	}
}

// Resolves the `break` statements of the form `break <args>` which tell the loop what to return.
func (cp *Compiler) resolveBreaksWithValue() {
	for _, item := range cp.forData[len(cp.forData)-1] {
		if item, ok := item.(bkBreakWithValue); ok {
			cp.vmComeFrom(item)
		}
	}
	cp.forData = cp.forData[:len(cp.forData)-1] // As this is the last thing we do with the data for this particular 'for' loop, we finish by popping it off the stack.
}

// Compile a `continue` in a `for loop`.
func (cp *Compiler) emitContinue(tok *token.Token) {
	if len(cp.forData) == 0 {
		cp.P.Throw("comp/for/continue", tok)
		return
	}
	cp.addToForData(cp.vmContinue())
}

func (cp *Compiler) vmContinue() bkContinue {
	cp.Emit(Jmp, DUMMY)
	return bkContinue(cp.CodeTop() - 1)
}

// COmpile `break` statements.
func (cp *Compiler) vmBreakWithoutValue() bkBreakWithoutValue {
	cp.Emit(Jmp, DUMMY)
	return bkBreakWithoutValue(cp.CodeTop() - 1)
}

func (cp *Compiler) vmBreakWithValue(mLoc uint32) bkBreakWithValue {
	cp.Emit(Asgm, DUMMY, mLoc)
	cp.Emit(Jmp, DUMMY)
	return bkBreakWithValue(cp.CodeTop() - 2)
}

func (cp *Compiler) emitBreakWithoutValue(tok *token.Token) {
	if len(cp.forData) == 0 {
		cp.P.Throw("comp/break/continue", tok)
		return
	}
	cp.addToForData(cp.vmBreakWithoutValue())
}

func (cp *Compiler) addToForData(x any) {
	cp.forData[len(cp.forData)-1] = append(cp.forData[len(cp.forData)-1], x)
}

func (cp *Compiler) forDataExists() bool {
	return len(cp.forData) > 0
}

// Either produces a lambda, if it has no closures, or we make a lambda factory and emit a `mkfn` instruction
// to produce a lambda from the lambda factory at runtime.
// TODO --- this is inside out, we should construct the factory if we need it rather than throwing it
// away if we don't.
func (cp *Compiler) compileLambda(env *Environment, ctxt context, fnNode *ast.FuncExpression, tok *token.Token) {
	cp.cm("Compiling lambda", tok)
	LF := &LambdaFactory{Model: &Lambda{}}
	newEnv := NewEnvironment()
	nameSig := fnNode.NameSig
	skipLambdaCode := cp.vmGoTo()
	LF.Model.capturesStart = cp.MemTop()
	cp.pushLambdaStart()

	// We get the function parameters. These shadow anything we might otherwise capture.
	params := dtypes.Set[string]{}
	for _, pair := range nameSig {
		params = params.Add(pair.VarName)
		if pair.VarType == "any?" {
			LF.Model.sig = append(LF.Model.sig, values.AbstractType{nil, DUMMY}) // 'nil' in a sig in this context means we don't need to typecheck.
		} else {
			LF.Model.sig = append(LF.Model.sig, cp.P.GetAbstractType(pair.VarType))
		}
	}
	LF.Model.tok = &fnNode.Token
	captures := ast.GetVariableNames(fnNode)
	for k := range captures {
		if params.Contains(k) {
			continue
		}
		v, ok := env.getVar(k)
		if !ok {
			cp.cm("Throwing unknown identifier error", tok)
			cp.P.Throw("comp/body/known", tok, k)
			return
		}
		if v.access == GLOBAL_CONSTANT_PRIVATE || v.access == GLOBAL_CONSTANT_PUBLIC || v.access == LOCAL_CONSTANT {
			cp.cm("Binding name "+text.Emph(k)+" in lambda to existing constant at location m"+strconv.Itoa(int(v.mLoc))+".", fnNode.GetToken())
			newEnv.data[k] = *v
		} else {
			cp.Reserve(values.UNDEFINED_VALUE, nil, fnNode.GetToken()) // It doesn't matter what we put in here 'cos we copy the values any time we call the LambdaFactory.
			cp.cm("Adding variable for lambda capture.", fnNode.GetToken())
			cp.AddVariable(newEnv, k, v.access, v.types, fnNode.GetToken())
		}
		// At the same time, the lambda factory need to know where they are in the calling vm.Vm.
		LF.CaptureLocations = append(LF.CaptureLocations, v.mLoc)
	}
	LF.Model.capturesEnd = cp.MemTop()

	potentialFuncs := ast.GetPrefixes(fnNode)
	for k := range potentialFuncs {
		v, ok := env.getVar(k)
		if ok {
			cp.cm("Binding name of function "+text.Emph(k)+" in lambda to existing constant at location m"+strconv.Itoa(int(v.mLoc))+".", fnNode.GetToken())
			newEnv.data[k] = *v
		}
	}

	cp.cm("Adding function parameters", tok)
	// Add the function parameters.
	for _, pair := range nameSig { // It doesn't matter what we put in here either, because we're going to have to copy the values any time we call the function.
		cp.Reserve(0, DUMMY, fnNode.GetToken())
		cp.cm("Adding parameter '"+pair.VarName+"' to lambda.", fnNode.GetToken())
		cp.AddVariable(newEnv, pair.VarName, FUNCTION_ARGUMENT, cp.getAlternateTypeFromTypeName(pair.VarType), fnNode.GetToken())
	}
	LF.Model.parametersEnd = cp.MemTop()

	// Compile the locals.
	saveThunkList := cp.ThunkList
	if fnNode.Given != nil {
		cp.ThunkList = []ThunkData{}
		newContext := ctxt
		newContext.env = newEnv
		newContext.access = LAMBDA
		cp.compileGivenBlock(fnNode.Given, newContext) // TODO --- must pass from outer context. TODO 2 --- what the hell did I mean by that?
	}

	// Function starts here.
	LF.Model.addressToCall = cp.CodeTop()

	// Initialize the thunks, if any.
	if fnNode.Given != nil {
		if len(cp.ThunkList) > 0 {
			cp.cm("Initializing thunks for lambda.", fnNode.GetToken())
		}
		for _, thunk := range cp.ThunkList {
			cp.Emit(Thnk, thunk.dest, thunk.value.MLoc, thunk.value.CAddr)
		}
		cp.ThunkList = saveThunkList
	}
	newRets := cp.returnSigToAlternateType(fnNode.NameRets)
	newContext := ctxt
	newContext.env = newEnv
	newContext.access = LAMBDA
	newContext.typecheck = newRets
	// Compile the main body of the lambda.
	types, _ := cp.CompileNode(fnNode.Body, newContext)
	LF.Model.resultLocation = cp.That()
	if fnNode.NameRets != nil {
		cp.cm("Typechecking returns from lambda.", fnNode.GetToken())
		cp.emitTypeChecks(LF.Model.resultLocation, types, env, fnNode.NameRets, LAMBDA, tok, CHECK_RETURN_TYPES)
	}
	cp.Emit(Ret)
	cp.popLambdaStart()
	cp.vmComeFrom(skipLambdaCode)

	// We have made our lambda factory! But do we need it? If there are no captures, then the function is a constant, and we
	// can just reserve it in memory.

	if captures.IsEmpty() {
		cp.cm("No captures. Emiting FUNC value.", fnNode.GetToken())
		cp.Reserve(values.FUNC, *LF.Model, fnNode.GetToken())
		return
	}
	cp.cm("Captures exist. Creating lambda factory.", fnNode.GetToken())
	cp.Vm.LambdaFactories = append(cp.Vm.LambdaFactories, LF)
	cp.put(Mkfn, uint32(len(cp.Vm.LambdaFactories)-1))
}

// Compiles a `given` block by calling the auxiliary function `getPartsOfGiven`, and then calling
// `compileOneGivenChunk one by one on the parts it returns.
func (cp *Compiler) compileGivenBlock(given ast.Node, ctxt context) {
	cp.cm("Compiling 'given' block.", given.GetToken())
	nameToNode := map[string]*ast.AssignmentExpression{}
	nameGraph := dtypes.Digraph[string]{}
	chunks := cp.getPartsOfGiven(given, ctxt)
	for _, chunk := range chunks {
		if chunk.GetToken().Type != token.GVN_ASSIGN {
			cp.P.Throw("comp/given/assign", chunk.GetToken())
			break
		}
		assEx := chunk.(*ast.AssignmentExpression)
		lhsSig, _ := cp.P.RecursivelySlurpSignature(assEx.Left, "*default*")
		rhs := ast.GetVariableNames(assEx.Right)
		for _, pair := range lhsSig {
			_, exists := ctxt.env.getVar(pair.VarName)
			if exists {
				cp.P.Throw("comp/given/exists", chunk.GetToken())
				return
			}
			nameToNode[pair.VarName] = assEx
			if reflect.TypeOf(assEx.Right) == reflect.TypeFor[*ast.FuncExpression]() {
				if len(rhs) == 0 { // Then the lambda has no captures and so is a constant.
					cp.cm("Reserving dummy local function "+text.Emph(pair.VarName)+".", assEx.GetToken())
					cp.Reserve(values.FUNC, nil, chunk.GetToken())
					cp.AddVariable(ctxt.env, pair.VarName, LOCAL_FUNCTION_CONSTANT, altType(values.FUNC), assEx.GetToken())
				} else {
					cp.cm("Reserving dummy local function thunk "+text.Emph(pair.VarName)+".", assEx.GetToken())
					cp.Reserve(values.THUNK, nil, chunk.GetToken())
					cp.AddVariable(ctxt.env, pair.VarName, LOCAL_FUNCTION_THUNK, altType(values.FUNC), assEx.GetToken())
				}
			}
			for v := range rhs {
				nameGraph.AddTransitiveArrow(pair.VarName, v)
			}
			if len(rhs) == 0 {
				nameGraph.AddTransitiveArrow(pair.VarName, "")
			}
		}
	}
	order, cycle := dtypes.Ordering(nameGraph)
	if cycle != nil {
		cp.P.Throw("comp/given/cycle", given.GetToken(), cycle)
	} else {
		used := dtypes.Set[string]{} // If we have a multiple assignment, we only want to compile the rhs once.
		for _, v := range order {
			node, ok := nameToNode[v]
			if ok && !used.Contains(v) {
				used.AddSet(dtypes.MakeFromSlice(cp.P.GetVariablesFromSig(node.Left)))
				cp.compileOneGivenChunk(node, ctxt)
			}
		}
	}
}

// Function auxiliary to the previous one, `compileGivenBlock`, to break down a `given` block into its
// component declarations so they can be passed one by one to the next function, `compileOneGivenBlock`.
func (cp *Compiler) getPartsOfGiven(given ast.Node, ctxt context) []ast.Node {
	result := []ast.Node{}
	switch branch := given.(type) {
	case *ast.LazyInfixExpression:
		if branch.Token.Literal == ";" {
			result = cp.getPartsOfGiven(branch.Left, ctxt)
			rhs := cp.getPartsOfGiven(branch.Right, ctxt)
			result = append(result, rhs...)
		} else {
			cp.P.Throw("comp/unexpected", given.GetToken())
		}
	default:
		result = []ast.Node{given}
	}
	return result
}

// As it says, compiles one expression from the `given` block. Called by `compileGivenBlock`.
func (cp *Compiler) compileOneGivenChunk(node *ast.AssignmentExpression, ctxt context) {
	cp.cm("Compiling one 'given' block assignment.", node.GetToken())
	oldThis, thisExists := ctxt.env.getVar("this")
	sig, err := cp.P.RecursivelySlurpSignature(node.Left, "any?")
	if err != nil {
		cp.P.Throw("comp/assign/lhs/a", node.Left.GetToken())
		return
	}
	rollbackTo := cp.getState()
	thunkStart := cp.Next()
	types, cst := cp.CompileNode(node.Right, ctxt.x())
	if recursivelyContains(types, simpleType(values.ERROR)) { // TODO --- this is a loathsome kludge over the fact that we're not constructing it that way in the first place.
		types = types.Union(altType(values.ERROR))
	}
	resultLocation := cp.That()
	if types.isOnly(values.ERROR) {
		cp.P.Throw("comp/assign/error", node.Left.GetToken())
		return
	}
	for i, pair := range sig {
		v, alreadyExists := ctxt.env.getVar(pair.VarName) // In that case we (should) have an inner function declaration and the sig will have length 1.
		// We check that it isn't just the user redefining a variable.
		if alreadyExists {
			if v.access == LOCAL_FUNCTION_THUNK && cp.Vm.Mem[v.mLoc].V == nil || v.access == LOCAL_FUNCTION_CONSTANT && cp.Vm.Mem[v.mLoc].V == nil {
				ctxt.env.data["this"] = *v
			} else {
				cp.P.Throw("comp/given/redeclared", node.GetToken(), pair.VarName)
				return
			}
		}
		var typeToUse AlternateType // TODO: we can extract more meaningful information about the tuple from the types.
		if pair.VarType == "tuple" {
			typeToUse = cp.Vm.AnyTuple
		} else {
			typeToUse = typesAtIndex(types, i)
		}
		if cst {
			if !types.containsAnyOf(cp.Vm.codeGeneratingTypes.ToSlice()...) {
				cp.cm("Adding foldable constant from compileOneGivenChunk.", node.GetToken())
				cp.AddVariable(ctxt.env, pair.VarName, LOCAL_CONSTANT, typeToUse, node.GetToken())
				cp.emitTypeChecks(resultLocation, types, ctxt.env, sig, ctxt.access, node.GetToken(), CHECK_GIVEN_ASSIGNMENTS)
				cp.Emit(Ret)
				if cp.P.ErrorsExist() {
					return
				}
				cp.cm("Calling Run from compileOneGivenChunk to fold constant.", node.GetToken())
				cp.Vm.Run(uint32(rollbackTo.code))
				v := cp.Vm.Mem[resultLocation]
				cp.rollback(rollbackTo, node.GetToken())
				cp.Reserve(v.T, v.V, node.GetToken())
				continue
			} else {
				cp.cm("Adding unfoldable constant from compileOneGivenChunk.", node.GetToken())
				cp.AddVariable(ctxt.env, pair.VarName, LOCAL_CONSTANT, typeToUse, node.GetToken())
			}
		} else {
			if alreadyExists {
				switch { // The case where neither of these is true has been checked for above.
				case v.access == LOCAL_FUNCTION_THUNK:
					cp.cm("Reassigning local function thunk "+text.Emph(pair.VarName)+" from dummy value.", node.GetToken())
					cp.Vm.Mem[v.mLoc] = val(values.THUNK, ThunkValue{cp.That(), thunkStart})
					cp.ThunkList = append(cp.ThunkList, ThunkData{v.mLoc, ThunkValue{cp.That(), thunkStart}})
				case v.access == LOCAL_FUNCTION_CONSTANT:
					cp.cm("Reassigning local function constant "+text.Emph(pair.VarName)+" from dummy value in compileOneGivenChunk.", node.GetToken())
					cp.Vm.Mem[v.mLoc] = cp.Vm.Mem[cp.That()]
				}
			} else {
				cp.cm("Reserving local thunk in compileOneGivenChunk.", node.GetToken())
				cp.Reserve(values.THUNK, ThunkValue{cp.That(), thunkStart}, node.GetToken())
				cp.AddVariable(ctxt.env, pair.VarName, LOCAL_VARIABLE_THUNK, typeToUse, node.GetToken())
				cp.ThunkList = append(cp.ThunkList, ThunkData{cp.That(), ThunkValue{cp.That(), thunkStart}})
			}
		}
	}
	cp.cm("Typechecking and inserting result into local variables.", node.GetToken())
	cp.emitTypeChecks(resultLocation, types, ctxt.env, sig, ctxt.access, node.GetToken(), CHECK_GIVEN_ASSIGNMENTS)
	if thisExists {
		ctxt.env.data["this"] = *oldThis
	} else {
		delete(ctxt.env.data, "this")
	}
	cp.Emit(Ret)
}

// Auxiliary functions for keeping track of compiling lambdas.
func (cp *Compiler) pushLambdaStart() {
	cp.lambdaMemStarts = append(cp.lambdaMemStarts, cp.MemTop())
}
func (cp *Compiler) popLambdaStart() {
	cp.lambdaMemStarts = cp.lambdaMemStarts[:len(cp.lambdaMemStarts)-1]
}
func (cp *Compiler) getLambdaStart() uint32 {
	return cp.lambdaMemStarts[len(cp.lambdaMemStarts)-1]
}

// A type and a function for making snippet factories.
type compiledSnippetKind int

const (
	VANILLA_SNIPPET compiledSnippetKind = iota
	SQL_SNIPPET
	HTML_SNIPPET
)

func (cp *Compiler) reserveSnippetFactory(t string, env *Environment, fnNode *ast.SuffixExpression, ctxt context) uint32 {
	cp.cm("Reserving snippet factory.", &fnNode.Token)
	snF := &SnippetFactory{snippetType: cp.ConcreteTypeNow(t), sourceString: fnNode.Token.Literal}
	csk := VANILLA_SNIPPET
	switch {
	case t == "SQL":
		csk = SQL_SNIPPET
	case t == "HTML":
		csk = HTML_SNIPPET
	}
	snF.bindle = cp.compileSnippet(fnNode.GetToken(), env, csk, snF.sourceString, ctxt)
	cp.Vm.SnippetFactories = append(cp.Vm.SnippetFactories, snF)
	return uint32(len(cp.Vm.SnippetFactories) - 1)
}

// Compiles a test for equality.
func (cp *Compiler) compileEquals(node *ast.ComparisonExpression, ctxt context) (AlternateType, bool) {
	lTypes, lcst := cp.CompileNode(node.Left, ctxt.x())
	if lTypes.isOnly(values.ERROR) {
		cp.P.Throw("comp/error/eq/a", node.GetToken())
		return AltType(values.ERROR), true
	}
	leftRg := cp.That()
	rTypes, rcst := cp.CompileNode(node.Right, ctxt.x())
	if rTypes.isOnly(values.ERROR) {
		cp.P.Throw("comp/error/eq/b", node.GetToken())
		return AltType(values.ERROR), true
	}
	rightRg := cp.That()
	oL := lTypes.intersect(rTypes)
	if oL.isOnly(values.ERROR) {
		cp.P.Throw("comp/error/eq/c", node.GetToken())
		return AltType(values.ERROR), true
	}
	if len(oL) == 0 {
		cp.P.Throw("comp/eq/types", node.GetToken())
		return AltType(values.ERROR), true
	}
	if len(oL) == 1 && len(lTypes) == 1 && len(rTypes) == 1 {
		switch el := oL[0].(type) { // TODO --- we can do as much of this stuff as actually makes things performant before handing it over to Eqxx
		case simpleType:
			switch el {
			case tp(values.INT):
				cp.put(Equi, leftRg, rightRg)
				return AltType(values.BOOL), lcst && rcst
			case tp(values.STRING):
				cp.put(Equs, leftRg, rightRg)
				return AltType(values.BOOL), lcst && rcst
			case tp(values.BOOL):
				cp.put(Equb, leftRg, rightRg)
				return AltType(values.BOOL), lcst && rcst
			case tp(values.FLOAT):
				cp.put(Equf, leftRg, rightRg)
				return AltType(values.BOOL), lcst && rcst
			case tp(values.TYPE):
				cp.put(Equt, leftRg, rightRg)
				return AltType(values.BOOL), lcst && rcst
			}
		}
	}
	cp.put(Eqxx, leftRg, rightRg, cp.reserveToken(node.GetToken()))
	return AltType(values.ERROR, values.BOOL), lcst && rcst
}

// Compiles a logging expression.
func (cp *Compiler) compileLog(node *ast.LogExpression, ctxt context) (uint32, bool) {
	output := uint32(DUMMY)
	logStr := node.Value
	strList, ok := text.GetTextWithBarsAsList(logStr)
	if !ok {
		cp.P.Throw("comp/log/close", &node.Token)
		return uint32(DUMMY), false
	}
	// So at this point we have a strList consisting of things which either do or don't need parsing and compiling,
	// depending on whether they are or aren't bracketed by | symbols.
	// If they don't need compiling they can just be concatenated to the output.
	errorReturns := []bkEarlyReturn{}
	for _, str := range strList {
		if str == "" {
			continue
		}
		if str[0] == '|' { // Then we must parse and compile.
			parsedAst := cp.P.ParseLine("code snippet in log expression", str[1:len(str)-1])
			sTypes, _ := cp.CompileNode(parsedAst, ctxt.x())
			thingToAdd := cp.That()
			if sTypes.Contains(values.ERROR) {
				errorReturns = append(errorReturns,
					cp.vmConditionalEarlyReturn(Qtyp, cp.That(), uint32(values.ERROR), cp.That()))
			}
			cp.put(Strx, thingToAdd)
			if output == DUMMY {
				output = cp.That()
			} else {
				cp.Emit(Adds, output, output, cp.That())
			}
			continue
		}
		// Otherwise, we just add it on as a string.
		cp.Reserve(values.STRING, str, node.GetToken())
		if output == DUMMY {
			output = cp.That()
		} else {
			cp.Emit(Adds, output, output, cp.That())
		}
	}
	for _, rtn := range errorReturns {
		cp.vmComeFrom(rtn)
	}
	return uint32(output), len(errorReturns) > 0
}

// The various 'piping operators'.
func (cp *Compiler) compilePipe(lhsTypes AlternateType, lhsConst bool, rhs ast.Node, env *Environment, ctxt context) (AlternateType, bool) {
	var envWithThat *Environment
	var isAttemptedFunc bool
	var v *variable
	typeIsNotFunc := bkEarlyReturn(DUMMY)
	var rtnTypes AlternateType
	var rtnConst bool
	lhs := cp.That()
	// If we have a any identifier, we wish it to contain a function ...
	switch rhs := rhs.(type) {
	case *ast.Identifier:
		v, ok := env.getVar(rhs.Value)
		if ok {
			cp.P.Throw("comp/pipe/pipe/ident", rhs.GetToken())
			return AltType(values.ERROR), true
		}
		isAttemptedFunc = true
		if !v.types.Contains(values.FUNC) {
			if rhs.GetToken().Literal == "that" { // Yeah it's a stupid corner case but the stupid user has a right to it.
				isAttemptedFunc = false
			} else {
				cp.P.Throw("comp/pipe/pipe/func", rhs.GetToken())
				return AltType(values.ERROR), true
			}
		}
		if !v.types.isOnly(values.FUNC) {
			cp.reserveError("vm/pipe/pipe/func", rhs.GetToken())
			cp.Emit(Qntp, v.mLoc, uint32(values.FUNC), cp.CodeTop()+3)
			typeIsNotFunc = cp.vmEarlyReturn(cp.That())
		}
	default:
		var whatAccess varAccess
		if lhsConst {
			whatAccess = VERY_LOCAL_CONSTANT
		} else {
			whatAccess = VERY_LOCAL_VARIABLE
		}
		envWithThat = &Environment{data: map[string]variable{"that": {mLoc: cp.That(), access: whatAccess, types: lhsTypes}}, Ext: env}
	}
	if isAttemptedFunc {
		cp.put(Dofn, v.mLoc, lhs)
		rtnTypes, rtnConst = cp.Vm.AnyTypeScheme, ALL_CONSTANT_ACCESS.Contains(v.access)
	} else {
		newContext := ctxt
		newContext.env = envWithThat
		rtnTypes, rtnConst = cp.CompileNode(rhs, newContext)
	}
	cp.vmComeFrom(typeIsNotFunc)
	return rtnTypes, rtnConst
}

func (cp *Compiler) compileMappingOrFilter(lhsTypes AlternateType, lhsConst bool, rhs ast.Node, env *Environment, ctxt context, isFilter bool) (AlternateType, bool) {
	tok := rhs.GetToken()
	if isFilter {
		cp.cm("Compiling filter.", tok)
	} else {
		cp.cm("Compiling mapping.", tok)
	}
	cp.cm("rhs is "+text.Emph(rhs.String()), tok)
	cp.cm("lhsTypes is "+text.Emph(lhsTypes.describe(cp.Vm)), tok)
	var rhsConst bool
	var isAttemptedFunc bool
	var v *variable
	inputElement := uint32(DUMMY)
	typeIsNotFunc := bkEarlyReturn(DUMMY)
	resultIsError := bkEarlyReturn(DUMMY)
	resultIsNotBool := bkEarlyReturn(DUMMY)
	lhsIsNotListlike := bkEarlyReturn(DUMMY)
	var types AlternateType
	sourceList := cp.That()
	envWithThat := &Environment{}
	thatLoc := uint32(DUMMY)

	overlap := lhsTypes.intersect(cp.Vm.sharedTypenameToTypeList["listlike"])
	if len(overlap) == 0 {
		cp.P.Throw("comp/pipe/mf/list", rhs.GetToken())
		return AltType(values.ERROR), true
	}
	if len(overlap) < len(lhsTypes) {
		err := cp.reserveError("vm/mf/lhs", rhs.GetToken())
		if len(overlap) == 1 {
			lhsIsNotListlike = cp.vmConditionalEarlyReturn(Qtyp, sourceList, uint32(overlap[0].(simpleType)), err)
		} else {
			args := []uint32{sourceList}
			for _, t := range overlap {
				args = append(args, uint32(t.(simpleType)))
			}
			args = append(args, err)
			lhsIsNotListlike = cp.vmConditionalEarlyReturn(Qabt, args...)
		}

	}

	// If we have a any identifier, we wish it to contain a function ...
	switch rhs := rhs.(type) {
	case *ast.Identifier:
		if rhs.GetToken().Literal != "that" {
			var ok bool
			v, ok = env.getVar(rhs.Value)
			if !ok {
				cp.P.Throw("comp/pipe/mf/ident", rhs.GetToken())
				return AltType(values.ERROR), true
			}
			isAttemptedFunc = true
			rhsConst = ALL_CONSTANT_ACCESS.Contains(v.access)
			if !v.types.Contains(values.FUNC) {
				cp.P.Throw("comp/pipe/mf/func", rhs.GetToken())
			}
			if !v.types.isOnly(values.FUNC) {
				cp.reserveError("vm/pipe/mf/func", rhs.GetToken())
				cp.Emit(Qntp, v.mLoc, uint32(values.FUNC), cp.CodeTop()+3)
				typeIsNotFunc = cp.vmEarlyReturn(cp.That())
			}
		}
	}
	if !isAttemptedFunc {
		rhsConst = true
		thatLoc = cp.Reserve(values.UNDEFINED_VALUE, DUMMY, rhs.GetToken())
		envWithThat = &Environment{data: map[string]variable{"that": {mLoc: cp.That(), access: VERY_LOCAL_VARIABLE, types: cp.getAlternateTypeFromTypeName("any?")}}, Ext: env}
	}
	counter := cp.Reserve(values.INT, 0, rhs.GetToken())
	accumulator := cp.Reserve(values.TUPLE, []values.Value{}, rhs.GetToken())
	cp.put(LenL, sourceList)
	length := cp.That()
	cp.cm("Start of loop.", tok)
	loopStart := cp.CodeTop()
	cp.cm("Check if the list is finished.", tok)
	cp.put(Gthi, length, counter)
	listFinished := cp.vmIf(Qtru, cp.That())
	cp.cm("Emit the body of the loop.", tok)
	if isAttemptedFunc {
		cp.cm("The rhs is a variable containing a function.", tok)
		cp.put(IdxL, sourceList, counter, DUMMY)
		inputElement = cp.That()
		cp.put(Dofn, v.mLoc, cp.That())
		types = AltType(values.ERROR).Union(cp.getAlternateTypeFromTypeName("any?")) // Very much TODO. Normally the function is constant and so we know its return types.
	} else {
		cp.cm("The rhs is an expression presumably containing 'that'.", tok)
		cp.Emit(IdxL, thatLoc, sourceList, counter, DUMMY)
		inputElement = thatLoc

		newContext := ctxt
		newContext.env = envWithThat
		types, _ = cp.CompileNode(rhs, newContext)
	}
	resultElement := cp.That()
	if types.Contains(values.ERROR) {
		cp.cm("If the result of the function's 'that' expression might be an error, we test for that and early-return the error if so.", tok)
		cp.Emit(Qtyp, resultElement, uint32(values.ERROR), cp.CodeTop()+3)
		resultIsError = cp.vmEarlyReturn(cp.That())
	}
	if isFilter {
		if !types.Contains(values.BOOL) {
			cp.P.Throw("comp/pipe/filter/bool", rhs.GetToken())
		}
		if !types.isOnly(values.BOOL) {
			cp.cm("The function we're filtering on might return something other than a boolean so we emit a check.", tok)
			cp.reserveError("vm/pipe/filter/bool", rhs.GetToken())
			cp.Emit(Qntp, resultElement, uint32(values.BOOL), cp.CodeTop()+3)
			resultIsNotBool = cp.vmEarlyReturn(cp.That())
		}
		cp.cm("We see if the result of the filter function is true and if so, we add it to the accumulator tuple.", tok)
		cp.Emit(Qtru, resultElement, cp.CodeTop()+2)
		cp.Emit(CcT1, accumulator, accumulator, inputElement)
	} else { // It's a map.
		cp.cm("We add the result of the mapping function to the accumulator tuple.", tok)
		cp.Emit(CcT1, accumulator, accumulator, resultElement)
	}
	cp.cm("We increment the counter and jump to the top of the loop.", tok) // TODO --- don't we have an increment opcode? Shouldn't we make one?
	cp.Emit(Addi, counter, counter, values.C_ONE)
	cp.Emit(Jmp, loopStart)
	cp.vmComeFrom(listFinished)
	cp.cm("We turn the accumulator tuple into a list and leave the result on top of memory.", tok)
	cp.put(List, accumulator)
	cp.vmComeFrom(typeIsNotFunc, resultIsError, resultIsNotBool, lhsIsNotListlike)
	cp.cm("We've finished compiling the mapping/filter operator.", tok)

	if types.Contains(values.ERROR) {
		return AltType(values.ERROR, values.LIST), lhsConst && rhsConst
	}
	return AltType(values.LIST), lhsConst && rhsConst
}

func (cp *Compiler) compileSnippet(tok *token.Token, newEnv *Environment, csk compiledSnippetKind, sText string, ctxt context) *SnippetBindle {
	cp.cm("Compile snippet", tok)
	bindle := SnippetBindle{compiledSnippetKind: csk}
	bits, ok := text.GetTextWithBarsAsList(sText)
	if !ok {
		cp.P.Throw("comp/snippet/form/b", tok)
		return &bindle
	}
	var buf strings.Builder
	bindle.codeLoc = cp.CodeTop()
	c := 0
	for _, bit := range bits {
		if len(bit) > 0 && bit[0] == '|' {
			node := cp.P.ParseLine(tok.Source, bit[1:len(bit)-1])
			newContext := ctxt
			newContext.env = newEnv
			types, cst := cp.CompileNode(node, newContext)
			val := cp.That()

			// Special sauce for the SQL snippets.
			if types.isOnly(values.TYPE) && cst && csk == SQL_SNIPPET {
				typeNumbers := cp.Vm.Mem[cp.That()].V.(values.AbstractType).Types
				if len(typeNumbers) == 1 && cp.Vm.concreteTypeInfo[typeNumbers[0]].isStruct() {
					sig, ok := cp.Vm.getSqlSig(typeNumbers[0])
					if !ok {
						cp.P.Throw("comp/snippet/sig", tok, cp.Vm.DescribeType(typeNumbers[0], LITERAL))
					}
					buf.WriteString(sig)
					continue // ... the for loop.
				}
			}
			// If it's a tuple of fixed length, we can split it and inject the values separately.
			// If it's of indeterminate length then we need to throw an error.
			numberOfInjectionSites := 1 // Default, if the type is any.
			if types.Contains(values.TUPLE) {
				lengths := lengths(types)
				if lengths.Contains(-1) || len(lengths) > 1 { // ... then we can't infer the length and must throw an error.
					cp.P.Throw("comp/snippet/tuple", tok)
				}
				numberOfInjectionSites, _ = lengths.GetArbitraryElement()
				for i := 0; i < numberOfInjectionSites; i++ {
					cp.put(IxTn, val, uint32(i))
					bindle.valueLocs = append(bindle.valueLocs, cp.That())
				}
			} else { // We have a any element so we add it to the injectable values.
				bindle.valueLocs = append(bindle.valueLocs, val)
			}
			sep := ""
			for i := 0; i < numberOfInjectionSites; i++ {
				buf.WriteString(sep)
				switch csk {
				case SQL_SNIPPET:
					buf.WriteString("$")
					c++
					buf.WriteString(strconv.Itoa(c)) // The injection sites in SQL go $1 , $2 , $3 ...
				case HTML_SNIPPET:
					buf.WriteString("{{index .Data ")
					buf.WriteString(strconv.Itoa(c)) // The injection sites in HTML go {{index .Data 0}} , {{index .Data 1}} ...
					buf.WriteString("}}")
					c++
				case VANILLA_SNIPPET:
					buf.WriteString("%v") // We produce a Go format string.
				}
				sep = ", "
			}
		} else {
			cp.Reserve(values.STRING, bit, tok)
			bindle.valueLocs = append(bindle.valueLocs, cp.That())
			buf.WriteString(bit)
		}
	}
	cp.Reserve(values.STRING, buf.String(), tok)
	bindle.objectStringLoc = cp.That()
	return &bindle
}

// To keep the following function from being many functions, we're going to pass it a thing modifying its behavior. Which, yeah,
// has its own problems. I should have written a Lisp in Lisp, I'd have been finished in half-an-hour.
type typeCheckFlavor int

// At present, the only three of these we actually switch on are CHECK_RETURN_TYPES, CHECK_GLOCBAL_ASSIGNMENTS, and CHECK_LAMBDA_PARAMETERS.
// The others are just meaningful ways of saying "none of the above".
const (
	CHECK_RETURN_TYPES typeCheckFlavor = iota
	CHECK_GIVEN_ASSIGNMENTS
	CHECK_BOUND_VARIABLE_ASSIGNMENTS
	CHECK_INITIALIZATION_ASSIGNMENTS
	CHECK_LAMBDA_PARAMETERS
	CHECK_LOCAL_CMD_ASSIGNMENTS // Note that in the case of multiple assignment, just one global
	CHECK_GLOBAL_ASSIGNMENTS    // variable on the left makes it global.
)

// We take (a location of) a any or tuple, the type as an AlternateType, a signature, an environment, a token, and a
// 'flavor' which says what exactly we're doing and in particular whether the sig contains names we should be inserting the tuple
// elements into or is just a return type signature in which case there will be no names and we can leave them as they are.
// We generate code which emits as much type-checking as is necessary given the fit of the signature to the AlternateType,
// and which inserts the values of the tuple into the variables specified in the signature.
// If the types cannot fit the sig we should of course emit a compile-time error. If they *may* not fit the sig, the runtime
// equivalent is to fill the parameters up with an error value generated from the token.
// If the sig is of an assignment in a command or a given block, then this is in fact all that needs to be done. If it's a
// lambda, then the rest of the code in the lambda can then return an error if passed one.
func (cp *Compiler) emitTypeChecks(loc uint32, types AlternateType, env *Environment, sig signature, ac cpAccess, tok *token.Token, flavor typeCheckFlavor) bkEarlyReturn {
	cp.cm("Emitting type checks.", tok)
	cp.cm("Sig names are "+text.Emph(getVarNames(sig))+".", tok)
	// The insert variable says whether we're just doing a typecheck against the sig or whether we're inserting values into variables.
	insert := (flavor != CHECK_RETURN_TYPES)
	// The earlyReturnOnFailure variable does what it sounds like. In the case when we are typechecking the arguments of a lambda or an assignment involving a global
	// variable, we have to be able to early-return the error.
	earlyReturnOnFailure := (flavor == CHECK_GLOBAL_ASSIGNMENTS || flavor == CHECK_LAMBDA_PARAMETERS)
	// And so this is the early return address that we're going to return to the caller if necessary, which can discharge it with a ComeFrom.
	errorCheck := bkEarlyReturn(DUMMY)
	errorLocation := cp.reserveError("vm/typecheck", tok)
	lengthCheck := bkIf(DUMMY)
	inputIsError := bkGoto(DUMMY)
	successfulSingleCheck := bkGoto(DUMMY)
	jumpToEnd := bkGoto(DUMMY)
	typeChecks := []bkGoto{}
	singles, tuples := types.splitSinglesAndTuples()
	acceptedSingles := AlternateType{}
	lastIsTuple := sig.Len() > 0 && cp.getTypes(sig, sig.Len()-1).containsOnlyTuples()
	if types.isOnly(values.ERROR) {
		cp.P.Throw("comp/typecheck/a", tok)
		return errorCheck
	}
	if types.Contains(values.ERROR) {
		cp.Emit(Qtyp, loc, uint32(values.ERROR), cp.CodeTop()+3)
		cp.Emit(Asgm, errorLocation, loc)
		inputIsError = cp.vmGoTo()
	}
	if sig.Len() > 0 {
		acceptedSingles = singles.intersect(cp.getTypes(sig, 0))
	}
	checkSingleType := bkGoto(DUMMY)
	if len(tuples) == 0 {
		if sig.Len() != 1 {
			cp.P.Throw("comp/typecheck/b", tok)
			return errorCheck
		}
	}
	if len(acceptedSingles) != len(singles) {
		checkSingleType = cp.emitTypeComparison(sig.GetVarType(0), loc, tok)
	}
	if insert {
		vData, _ := env.getVar(sig.GetVarName(0)) // It is assumed that we've already made it exist.
		if vData.access == REFERENCE_VARIABLE {
			if lastIsTuple {
				cp.put(Cv1T, loc)
				cp.Emit(Aref, vData.mLoc, cp.That())
			} else {
				cp.Emit(Aref, vData.mLoc, loc)
			}
		} else {
			if lastIsTuple {
				cp.Emit(Cv1T, vData.mLoc, loc)
			} else {
				cp.Emit(Asgm, vData.mLoc, loc)
			}
		}
	}
	cp.vmComeFrom(checkSingleType)
	isTuple := bkIf(DUMMY)
	if len(tuples) == 0 {
		successfulSingleCheck = cp.vmGoTo()
	} else {
		isTuple = cp.vmIf(Qtyp, loc, uint32(values.TUPLE))
		lengths := lengths(tuples)
		goodLengths := 0
		badLengths := 0
		for ln := range lengths {
			if ln == -1 { // If the tuple can be any length then this is good only if the 0dx type of the sig is a tuple.
				if lastIsTuple && sig.Len() == 1 {
					goodLengths++
				}
				continue
			}
			if ln == sig.Len() || lastIsTuple && ln >= sig.Len()-1 {
				goodLengths++
			} else {
				badLengths++
			}
		}
		if badLengths == len(lengths) {
			cp.P.Throw("comp/typecheck/c", tok)
			return errorCheck
		}

		if goodLengths != len(lengths) {
			if lastIsTuple {
				lengthCheck = cp.vmIf(QlnT, loc, uint32(len(lengths)))
			} else {
				lengthCheck = cp.vmIf(QleT, loc, uint32(len(lengths)))
			}
		}
		lookTo := sig.Len()
		if lastIsTuple {
			lookTo := lookTo - 1
			vr, _ := env.getVar(sig.GetVarName(sig.Len() - 1))
			cp.Emit(SlTn, vr.mLoc, loc, uint32(lookTo)) // Gets the end of the slice. We can put anything in a tuple.
		}
		elementLoc := uint32(DUMMY)
		// Now let's typecheck the other things.
		for i := 0; i < sig.Len(); i++ {
			typesToCheck := typesAtIndex(types, i)
			sigTypes := cp.getTypes(sig, i)
			overlap := typesToCheck.intersect(sigTypes)
			if len(overlap) == 0 || overlap.isOnly(values.ERROR) {
				cp.P.Throw("comp/typecheck/d", tok)
				return errorCheck
			}
			if len(overlap) == len(typesToCheck) {
				continue
			}
			if elementLoc == DUMMY {
				elementLoc = cp.Reserve(values.UNDEFINED_VALUE, nil, tok)
			}
			cp.Emit(IxTn, elementLoc, loc, uint32(i))
			typeCheck := cp.emitTypeComparison(sig.GetVarType(i), elementLoc, tok)
			typeChecks = append(typeChecks, typeCheck)
		}

		// At this point if we're not inserting into the sig but just checking, then our work is done --- the original location we were passed, if it
		// contained an unacceptable type, now contains a type error, and if it didn't, it doesn't.
		// If however we are inserting things into the sig then we do that now.
		if insert {
			for i := 0; i < lookTo; i++ {
				vr, _ := env.getVar(sig.GetVarName(i))
				if vr.access == REFERENCE_VARIABLE {
					cp.put(IxTn, loc, uint32(i))
					cp.Emit(Aref, vr.mLoc, cp.That())
				} else {
					cp.Emit(IxTn, vr.mLoc, loc, uint32(i))
				}
			}
		}
		jumpToEnd = cp.vmGoTo()
	}

	cp.vmComeFrom(lengthCheck, inputIsError) // This is where we jump to if we fail any of the runtime tests.
	if len(tuples) == 0 {
		cp.vmComeFrom(checkSingleType)
	}
	for _, tc := range typeChecks {
		cp.vmComeFrom(tc)
	}

	// If we're putting things into a signature, then on error we want those things to contain the error, unless
	// it contains a global variable or we're typechecking a function, in which case we need an early return.
	// If we're just typechecking it, then we want to replace it with an error --- that is, a function trying to
	// return a tuple containing an error should just return the error.
	switch {
	case earlyReturnOnFailure:
		errorCheck = cp.vmEarlyReturn(errorLocation)
	case insert:
		for i := 0; i < sig.Len(); i++ {
			vr, _ := env.getVar(sig.GetVarName(i))
			cp.Emit(Asgm, vr.mLoc, errorLocation)
		}
	default:
		cp.Emit(Asgm, loc, errorLocation)
	}
	cp.vmComeFrom(successfulSingleCheck, jumpToEnd, isTuple)
	return errorCheck
}

// Adds a variable to a given environment.
func (cp *Compiler) AddVariable(env *Environment, name string, acc varAccess, types AlternateType, tok *token.Token) {
	cp.cm("Adding variable name "+text.Emph(name)+" bound to memory location m"+strconv.Itoa(int(cp.That()))+" with type "+types.describe(cp.Vm), tok)
	env.data[name] = variable{mLoc: cp.That(), access: acc, types: types}
}

// A couple of types to support thunking.
//
// This contains what the compiler needs to emit the 'thnk' operations at the start of a function.
type ThunkData struct {
	dest  uint32
	value ThunkValue
}

// This is the data that goes inside a THUNK value.
type ThunkValue struct {
	MLoc  uint32 // The place in memory where the result of the thunk ends up when you unthunk it.
	CAddr uint32 // The code address to call to unthunk the thunk.
}

type bkRecursion struct{ functionNumber, address uint32 }

// The compiler's representation of a function after the function has been compiled.
type CpFunc struct {
	CallTo                  uint32
	LoReg                   uint32
	HiReg                   uint32
	OutReg                  uint32
	locOfTupleAndVarargData uint32
	RtnTypes                AlternateType
	Builtin                 string   // The name of a builtin or constructor, or an empty string if it's neither.
	Xcall                   *XBindle // Information for making an external call, if non-nil.
	Private                 bool     // True if it's private.
	Command                 bool     // True if it's a command.
	GoNumber                uint32
	HasGo                   bool
}

// Information we need in the CpFunc struct to call an external service.
type XBindle struct {
	ExternalServiceOrdinal uint32
	FunctionName           string
	Position               uint32
}

// This and the following exist because the compiler can infer a wider range of types for e.g. a variable than
// the parser has words for.
type signature interface {
	GetVarName(i int) string
	GetVarType(i int) any
	Len() int
}

type cpSig []ast.NameTypePair

func (cs cpSig) GetVarName(i int) string {
	return cs[i].GetName()
}

func (cs cpSig) GetVarType(i int) any {
	return cs[i].GetType()
}

func (cs cpSig) Len() int {
	return len(cs)
}

// The maximum value of a `uint32`. Used as a dummy/sentinel value when `0` is not appropriate.
const DUMMY = 4294967295

// Housekeeping functions for keeping track of the `resolving compilers`, i.e. which one is suitable
// for the namespace we find ourselves in.
func (p *Compiler) pushRCompiler(q *Compiler) {
	p.labelResolvingCompilers = append(p.labelResolvingCompilers, q)
}
func (p *Compiler) topRCompiler() *Compiler {
	return p.labelResolvingCompilers[len(p.labelResolvingCompilers)-1]
}
func (p *Compiler) popRCompiler() {
	p.labelResolvingCompilers = p.labelResolvingCompilers[1:]
}

// Types and functions to help with housekeeping. It stores the declarations of types and functions in a map
// keyed by their source and line number. This is to prevent the same source code being compiled twice onto
// the same VM, which only needs it once.
type declarationOf int

const (
	decSTRUCT declarationOf = iota
	decLABEL
	decENUM
	decCLONE
	decABSTRACT
	decINTERFACE
	decFUNCTION
)

type labelInfo struct {
	loc     uint32 // The location in the VM where we store a value {LABEL, n}.
	private bool
}

type structInfo struct {
	structNumber values.ValueType
	private      bool
}

type fnSigInfo struct {
	name   string
	sig    ast.StringSig
	rtnSig ast.StringSig
}

type interfaceInfo struct {
	sigs []fnSigInfo
}

// A function to find out if the source has changed and we need to recompile. TODO --- because of NULL-imports there is no longer such a thing as "the" source and you'll have to keep a list.
func (cp *Compiler) NeedsUpdate() (bool, error) {
	if len(cp.ScriptFilepath) >= 5 && cp.ScriptFilepath[0:5] == "http:" || len(cp.ScriptFilepath) >= 11 && cp.ScriptFilepath[0:11] == "test-files/" {
		return false, nil
	}
	file, err := os.Stat(cp.ScriptFilepath)
	if err != nil {
		return false, err
	}
	currentTimeStamp := file.ModTime().UnixMilli()
	if cp.Timestamp != currentTimeStamp {
		return true, nil
	}
	for _, imp := range cp.Services {
		impNeedsUpdate, impError := imp.Cp.NeedsUpdate()
		if impNeedsUpdate || impError != nil {
			return impNeedsUpdate, impError
		}
	}
	return false, nil
}

// Types and functions for "backtracking". When we need to emit an opcode with operands we don't know yet (e.g.
// if they involve jumping over a block of code we haven't emitted yet) we stash some backtracking information
// on a stack or list or whatever and then resolve it when we have the requisite information.

type bkIf int

func (cp *Compiler) vmIf(oc Opcode, args ...uint32) bkIf {
	cp.Emit(oc, (append(args, DUMMY))...)
	return bkIf(cp.CodeTop() - 1)
}

type bkGoto int

type bkContinue int

type bkBreakWithValue int

type bkBreakWithoutValue int

func (cp *Compiler) vmGoTo() bkGoto {
	cp.Emit(Jmp, DUMMY)
	return bkGoto(cp.CodeTop() - 1)
}

type bkEarlyReturn int

func (cp *Compiler) vmEarlyReturn(mLoc uint32) bkEarlyReturn {
	cp.Emit(Asgm, DUMMY, mLoc)
	cp.Emit(Jmp, DUMMY)
	return bkEarlyReturn(cp.CodeTop() - 2)
}

func (cp *Compiler) vmConditionalEarlyReturn(oc Opcode, args ...uint32) bkEarlyReturn {
	mLoc := args[len(args)-1]
	cp.Emit(oc, append(args[:len(args)-1], cp.CodeTop()+3)...)
	return cp.vmEarlyReturn(mLoc)
}

// The `vmComeFrom` function knows how to resolve the various bits of backtracking data.
func (cp *Compiler) vmComeFrom(items ...any) {
	for _, item := range items {
		switch item := item.(type) {
		case bkBreakWithValue:
			if uint32(item) == DUMMY {
				continue
			}
			cp.Vm.Code[uint32(item)].Args[0] = cp.That()
			cp.Vm.Code[uint32(item)+1].MakeLastArg(cp.CodeTop())
		case bkBreakWithoutValue:
			if uint32(item) == DUMMY {
				continue
			}
			cp.Vm.Code[uint32(item)].MakeLastArg(cp.CodeTop())
		case bkContinue:
			if uint32(item) == DUMMY {
				continue
			}
			cp.Vm.Code[uint32(item)].MakeLastArg(cp.CodeTop())
		case bkGoto:
			if uint32(item) == DUMMY {
				continue
			}
			cp.Vm.Code[uint32(item)].MakeLastArg(cp.CodeTop())
		case bkIf:
			if uint32(item) == DUMMY {
				continue
			}
			cp.Vm.Code[uint32(item)].MakeLastArg(cp.CodeTop())
		case bkEarlyReturn:
			if uint32(item) == DUMMY {
				continue
			}
			cp.Vm.Code[uint32(item)].Args[0] = cp.That()
			cp.Vm.Code[uint32(item)+1].MakeLastArg(cp.CodeTop())
		default:
			panic("Can't ComeFrom that!")
		}
	}
}

// Functions for the compiler to inspect and write to the VM.

// We have two different ways of emiting an opcode: 'Emit' does it the regular way, 'put' ensures that
// the destination is the next free memory address.
func (cp *Compiler) Emit(opcode Opcode, args ...uint32) {
	cp.Vm.Code = append(cp.Vm.Code, MakeOp(opcode, args...))
	if cp.showCompile {
		description := cp.Vm.DescribeCode(cp.CodeTop() - 1)
		if !testing.Testing() {
			println(description)
		}
	}
}

func (cp *Compiler) put(opcode Opcode, args ...uint32) {
	args = append([]uint32{cp.MemTop()}, args...)
	cp.Emit(opcode, args...)
	cp.Vm.Mem = append(cp.Vm.Mem, values.Value{})
}

func (cp *Compiler) emitCallOpcode(funcNumber uint32, valLocs []uint32) {
	if funcNumber >= uint32(len(cp.Fns)) {
		args := append([]uint32{DUMMY, DUMMY, DUMMY}, valLocs...)
		cp.Emit(Call, args...) // TODO --- find out from the sig whether this should be CalT.
		return
	}
	args := append([]uint32{cp.Fns[funcNumber].CallTo, cp.Fns[funcNumber].LoReg, cp.Fns[funcNumber].HiReg}, valLocs...)
	if cp.Fns[funcNumber].locOfTupleAndVarargData == DUMMY { // We specialize on whether we have to capture tuples or varargs.
		cp.Emit(Call, args...)
	} else {
		cp.Emit(CalT, args...) // As the data about tuples and varargs must have been stored in cp.Fns[funcNumber].HiReg if it exists, we don't need to supply anything mre in the opcode.
	}
}

func (cp *Compiler) Describe(v values.Value) string {
	return cp.Vm.Literal(v)
}

func (cp *Compiler) Reserve(t values.ValueType, v any, tok *token.Token) uint32 {
	if t < values.ValueType(len(cp.Vm.concreteTypeInfo)) {
		cp.cm("Reserving m"+strconv.Itoa(len(cp.Vm.Mem))+" with initial type "+cp.Vm.DescribeType(t, LITERAL)+".", tok) // E.g. the members of enums get created before their type. TODO --- is there a reason for this?
	} else {
		cp.cm("Reserving m"+strconv.Itoa(len(cp.Vm.Mem))+" for initial type not yet named.", tok)
	}
	cp.Vm.Mem = append(cp.Vm.Mem, val(t, v))
	return uint32(len(cp.Vm.Mem) - 1)
}

func (cp *Compiler) reserveError(ec string, tok *token.Token, args ...any) uint32 {
	cp.Vm.Mem = append(cp.Vm.Mem, val(values.ERROR, &err.Error{ErrorId: ec, Token: tok, Args: args, Trace: make([]*token.Token, 0, 10)}))
	cp.cm("Reserving error '"+ec+"' at m"+strconv.Itoa(int(cp.That()))+".", tok)
	return cp.That()
}

func (cp *Compiler) reserveToken(tok *token.Token) uint32 {
	cp.Vm.Tokens = append(cp.Vm.Tokens, tok)
	return cp.ThatToken()
}

func (cp *Compiler) MemTop() uint32 {
	return uint32(len(cp.Vm.Mem))
}

func (cp *Compiler) That() uint32 {
	return uint32(len(cp.Vm.Mem) - 1)
}

func (cp *Compiler) ThatToken() uint32 {
	return uint32(len(cp.Vm.Tokens) - 1)
}

func (cp *Compiler) CodeTop() uint32 {
	return uint32(len(cp.Vm.Code))
}

func (cp *Compiler) TokenTop() uint32 {
	return uint32(len(cp.Vm.Tokens))
}

func (cp *Compiler) LfTop() uint32 {
	return uint32(len(cp.Vm.LambdaFactories))
}

func (cp *Compiler) Next() uint32 {
	return uint32(len(cp.Vm.Code))
}

// This captures the record.
func (cp *Compiler) getState() vmState {
	return vmState{len(cp.Vm.Mem), len(cp.Vm.Code), len(cp.Vm.Tokens), len(cp.Vm.LambdaFactories), len(cp.Vm.SnippetFactories)}
}

// And this rolls back the machine.
func (cp *Compiler) rollback(vms vmState, tok *token.Token) {
	cp.cm("Rolling back to address "+strconv.Itoa(vms.code)+" and location "+strconv.Itoa(vms.mem)+".", tok)
	cp.Vm.Code = cp.Vm.Code[:vms.code]
	cp.Vm.Mem = cp.Vm.Mem[:vms.mem]
	cp.Vm.Tokens = cp.Vm.Tokens[:vms.tokens]
	cp.Vm.LambdaFactories = cp.Vm.LambdaFactories[:vms.lambdaFactories]
	cp.Vm.SnippetFactories = cp.Vm.SnippetFactories[:vms.snippetFactories]
}

// For calling `init` or `main`.
func (cp *Compiler) CallIfExists(name string) values.Value {
	tree, ok := cp.P.FunctionForest[name]
	if !ok {
		return values.UNDEF
	}
	for _, t := range tree.Tree.Branch {
		if t.Type.Len() == 0 && t.Node.Fn != nil {
			cp.Vm.Run(cp.Fns[t.Node.Fn.Number].CallTo)
			return cp.Vm.Mem[cp.Fns[t.Node.Fn.Number].OutReg]
		}
	}
	return values.UNDEF
}

// Functions for emitting comments on what the compiler is doing, if the option to do so in the `settings.go`
// file is set to `true`.

// The regular version, in cyan.
func (cp *Compiler) cm(comment string, tok *token.Token) {
	if settings.SHOW_COMPILER_COMMENTS && !(settings.IGNORE_BOILERPLATE && settings.ThingsToIgnore.Contains(tok.Source)) {
		println(text.CYAN + "// " + comment + text.RESET)
	}
}

// The same as the previous method but in purple. Used to comment on the resolution of the multiple dispatch in particular.
func (cp *Compiler) cmP(comment string, tok *token.Token) {
	if settings.SHOW_COMPILER_COMMENTS && !(settings.IGNORE_BOILERPLATE && settings.ThingsToIgnore.Contains(tok.Source)) {
		println(text.PURPLE + "// " + comment + text.RESET)
	}
}

// The same as the previous methods but in red. Used to draw attention to new comments which will either be downgraded to cyan or purple or removed.
func (cp *Compiler) cmR(comment string, tok *token.Token) {
	if settings.SHOW_COMPILER_COMMENTS && !(settings.IGNORE_BOILERPLATE && settings.ThingsToIgnore.Contains(tok.Source)) {
		println(text.RED + "// " + comment + text.RESET)
	}
}

// The compiler keeps its errors in the CommonParserBindle like eveerything else, and accesses them through
// its parser.

func (cp *Compiler) Throw(errorID string, tok token.Token, args ...any) {
	cp.P.Throw(errorID, &tok, args...)
}

func (cp *Compiler) ErrorsExist() bool {
	return len(cp.P.Common.Errors) > 0
}

func (cp *Compiler) ReturnErrors() string {
	return cp.P.ReturnErrors()
}
