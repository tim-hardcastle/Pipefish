import

golang "time"

newtype

Weekday = enum SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
Clock = struct()
Time = struct(year, month, day, hour, minute, second, nanosecond int, location string)

cmd 

get (x ref) from (c Clock) :
    x = goGetClock() 

def

add (t Time, duration int) -> Time : golang {
    return goToPf(pfToGo(t).Add(time.Duration(duration)))
}

addDate(t Time, years, months, days int) -> Time : golang {
    return goToPf(pfToGo(t).AddDate(years, months, days))
} 

after(t, u Time) -> bool : golang {
    return pfToGo(t).After(pfToGo(u))
}

before(t, u Time) -> bool : golang {
    return pfToGo(t).Before(pfToGo(u))
}

compare(t, u Time) -> int : golang {
    return pfToGo(t).Compare(pfToGo(u))
}

equal(t, u Time) -> bool : golang {
    return pfToGo(t).Equal(pfToGo(u))
}

format(t Time, layout string) -> string : golang {
    return pfToGo(t).Format(layout)
}

isDst(t Time) -> bool : golang {
    return pfToGo(t).IsDST()
}

ISOWeek(t Time) -> int, int : golang {
    return pfToGo(t).ISOWeek()
}

isZero(t Time) -> bool : golang {
    return pfToGo(t).IsZero()
}

local(t Time) -> Time : golang {
    return goToPf(pfToGo(t).Local())
}

parse(layout, value string) : golang {
    newTime, err := time.Parse(layout, value)
    if err != nil {
        return err
    }
    return goToPf(newTime)
}

parseDuration(s string) : golang {
    dur, err := time.ParseDuration(s)
    if err != nil {
        return err
    }
    return int(dur)
}

round(t Time, duration int) -> Time : golang {
    return goToPf(pfToGo(t).Round(time.Duration(duration)))
}

sub (t, u Time) -> int : golang {
    return int(pfToGo(t).Sub(pfToGo(u)))
}

timeIn(t Time, location string) : golang {
    newLoc, err := time.LoadLocation(location)
    if err != nil {
        return err
    }
    return goToPf(pfToGo(t).In(newLoc))
}

timeToUnix(t Time) -> int : golang {
    return int(pfToGo(t).Unix())
}

timeToUnixMicro(t Time) -> int : golang {
    return int(pfToGo(t).UnixMicro())
}

timeToUnixMilli(t Time) -> int : golang {
    return int(pfToGo(t).UnixMilli())
}

timeToUnixNano(t Time) -> int : golang {
    return int(pfToGo(t).UnixNano())
}

truncate(t Time, duration int) -> Time : golang {
    return goToPf(pfToGo(t).Truncate(time.Duration(duration)))
}

unixToTime(sec, usec int) -> Time : golang {
    return goToPf(time.Unix(int64(sec), int64(usec)))
}

unixMicroToTime(usec int) -> Time : golang {
    return goToPf(time.UnixMicro(int64(usec)))
}

unixMilliToTime(msec int) -> Time : golang {
    return goToPf(time.UnixMilli(int64(msec)))
}

UTC(t Time) -> Time : golang {
    return goToPf(pfToGo(t).UTC())
}

weekday(t Time) -> Weekday :
    Weekday[goWeekday(t)]

goWeekday(t Time) -> int : golang {
    return int((pfToGo(t)).Weekday())
}

yearDay(t Time) -> int : golang {
    return (pfToGo(t)).YearDay()
}

private 

goGetClock() -> Time : golang {
    goNow := time.Now()
    return Time{goNow.Year(), int(goNow.Month()), goNow.Day(), goNow.Hour(), goNow.Minute(), goNow.Second(), goNow.Nanosecond(), goNow.Location().String()}
}

golang {

    func pfToGo(t Time) time.Time {
        locObj, _ := time.LoadLocation(t.Location)
        goMonth := time.Month(t.Month)
        return time.Date(t.Year, goMonth, t.Day, t.Hour, t.Minute, t.Second, t.Nanosecond, locObj)
    }

    func goToPf(t time.Time) Time {
        return Time{t.Year(), int(t.Month()), t.Day(), t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), t.Location().String()}
    }

}

